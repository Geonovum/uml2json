// == Clause containing normative material

// Paragraph

// === Requirement Class A or Requirement A Example

// Paragraph – intro text for the requirement class.

// Use the following table for Requirements Classes.

// include::../requirements/requirements_class.adoc[]

// ==== Requirement 1

// Paragraph - intro text for the requirement.

// Use the following table for Requirements, number sequentially.

// include::../requirements/requirement.adoc[]

// Dictionary tables for requirements can be added as necessary. Modify the following example as needed.

// [width="90%",options="header"]
// |===
// |Names |Definition |Data types and values |Multiplicity and use
// |name 1 |definition of name 1 |float |One or more (mandatory)
// |name 2 |definition of name 2 |character string type, not empty |Zero or one (optional)
// |name 3 |definition of name 3 |GML:: Point PropertyType |One (mandatory)
// |===
[[jsonschema]]
== UML to JSON Schema Encoding Rules

[[jsonschema_schemaconversionrules]]
=== Schema Conversion Rules

The following subsections describe a number of conversion rules, which define how the content of an application schema, represented using UML as the conceptual schema language, is converted to JSON Schema.

NOTE: An encoding rule consists of a set of conversion rules – as required by a community. The <<jsonschema_encodingrules>> section describes two such rules - one for a GeoJSON compliant encoding, and one for a plain JSON encoding.

[[jsonschema_schemaconversionrules_documentation]]
==== Documentation

// implementation status: not implemented

With __rule-json-all-documentation__, descriptive information of application schema elements (packages, classes, properties, and associations) can be encoded via JSON Schema _annotations_.

[NOTE]
======
_Annotations_ represent one category of JSON Schema keywords (for further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02#section-7[JSON Schema core, section 7]). _Annotations_ attach information that applications may use as they see fit. The other categories are _assertions_, which validate that a JSON instance satsifies constraints, and _applicators_, which apply subschemas to parts of the instance and combine their results.

======

[WARNING]
======
In UGAS-2020, only the design for converting the documentation of application schema elements has been developed. __rule-json-all-documentation__ has not been implemented in UGAS-2020, for two reasons.

. Omitting the documentation will result in significantly smaller JSON Schema documents. The reduction of file size is preferable for processes that need to download the schema in order to apply validation. This is even more important if cross-references between JSON Schemas exist.
. When validating JSON data against a JSON Schema, a JSON Schema validator typically focuses on the JSON Schema assertions and applicators, and will ignore most JSON Schema annotations - especially https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9[meta-data annotations], such as "title" and "description."

// interesting:
// https://json-schema-editor.tangramjs.com/index.html
// https://json-schema.org/implementations.html#editors

======

Descriptive information of a model element in ShapeChange, i.e., properties (attributes and association roles), classes, and packages, includes the pieces of information, called _descriptors_, that are documented in <<table_descriptors>>.

NOTE: A model element can have all, a subset, or none of these descriptors.

[#table_descriptors,reftext='{table-caption} {counter:table-num}']
.Well-known descriptors
[cols="1,3a",options="header"]
|====================
| Descriptor Name +
(and ID) | Explanation
| Name +
(name) | The name of the model element (as named in the source UML, i.e., using upper and lower camel case).
| Alias +
(alias) | An alternative, human-readable name for the model element.
| Definition +
(definition) | The normative specification of the model element.
| Description +
(description) | Additional information about the model element.
| Documentation +
(documentation) | The overall documentation of the model element. May be structured, containing other descriptors (such as definition and description).
| Example(s) +
(example) | Example(s) illustrating the model element.
| Global identifier +
(globalIdentifier) | The globally unique identifier of the model element; that is, unique across models.
| Legal basis +
(legalBasis) | The legal basis for the model element.
| Data capture statement(s) +
(dataCaptureStatement) | Statement(s) describing how to capture instances of this model element from the real world.
| Primary code +
(primaryCode) | The primary code for this model element. +

NOTE: The main code for a model element should be assigned to this descriptor. The primary code may be the only one. Optional additional tagged values may be added for other codes.
|====================

NOTE: The descriptor ID is used in ShapeChange configuration elements that define JSON Schema annotations.

Typically, a community has a preferred way to model and encode this information. For example, one community may want to encode the description of a model element via the "description" annotation (which is one of a set of basic meta-data annotations defined in https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9[JSON Schema validation, section 9]), while another may prefer to encode the values of multiple descriptors of a model element within a single "description" annotation.

ShapeChange can support this type of diversity through _JSON Schema annotation_ elements, which can be defined in the ShapeChange configuration. An annotation element specifies how the content of a specific JSON Schema annotation (that shall be generated while converting a model element) shall be constructed. The annotation element takes into account that a UML model element may not have an actual value for a descriptor, and that some descriptors can have multiple values, e.g., the descriptor _example_.

In addition to the well-known descriptors (see <<table_descriptors,previous table>>), additional descriptive information can be incorporated through UML tagged values from the application schema. For example, the "name" tagged value on classes in the NAS could be used to create a JSON Schema "title" annotation.

Different types of annotation elements are available for configuring a ShapeChange JSON Schema target.

* JsonSchemaNumberAnnotation - For annotations with a(n array of) JSON number(s) as value.
* JsonSchemaBooleanAnnotation - For annotations with a(n array of) JSON boolean(s) as value.
* JsonSchemaStringAnnotation - For annotations with a(n array of) JSON string(s) as value.
* JsonSchemaTemplateAnnotation - For annotations with a(n array of) JSON string(s) as value, defined via a template that can include multiple descriptors and tagged values.

NOTE: The JSON Schema annotation "examples," defined by https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9.5[JSON Schema validation, section 9.5], is an example for an annotation that has a JSON array as value, with the type of array items being unrestricted. In other words, the array can contain mixed value types. The "examples" annotation can thus have an array of strings (e.g., ["abc","xyz"]), numbers (e.g., [4,2]), booleans (e.g., [true, true]), and a mix thereof (e.g., ["abc", 2, true]) as value.

NOTE: ShapeChange JSON Schema annotation elements are not designed to support the creation of annotations with complex JSON arrays or objects as value. Only simple values, or an array thereof, can be created. So far, no use cases have been identified that require a more complex annotation value. In the future, if such use cases were identified, ShapeChange could be extended to support them.

The following two tables document the structure of ShapeChange JSON Schema annotation elements. <<example_shapechange_jsonschema_annotation_elements>> provides examples.

[#table_jsonschema_annotation_element1,reftext='{table-caption} {counter:table-num}']
.ShapeChange JSON Schema annotation element - for annotations with string, number, or boolean values
[cols="1,1,1,1,6a",options="header"]
|===
| Configuration Information Item | Datatype & Structure | Required / Optional | Default Value | Description
| annotation | string | Required | _not applicable_ | Name of the JSON Schema annotation keyword that shall be added to the JSON Schema element which represents the UML model element.
| descriptorOr TaggedValue | string | Required | _not applicable_ | Either a _descriptor-ID_, identifying one of the <<table_descriptors,well-known descriptors>>, or a string identifying a tagged value.

In order to identify a tagged value, add prefix "TV:" to the name of the tagged value. If a tagged value is known to contain a list of values, combined in a string using a specific separator, and these values shall be used as individual values, rather than using the whole string as value, use the prefix "TV(_separator_):," followed by the tag name. ShapeChange will then split the tagged value around matches of the given separator (which is treated as a literal).

Note that the type of the ShapeChange JSON Schema annotation element defines how ShapeChange will encode the values of the descriptor / tagged value.

* In case of a string annotation, each value will be quoted.
* In case of a number annotation, each value will be encoded as-is, i.e., without quotes.
* In case of a boolean annotation, each value will be parsed: if the value is "True" (ignoring case") or 1, then the value will be encoded as the JSON value __true__; otherwise it will be encoded as the JSON value __false__.
| noValueBehavior | enum: _ignore_ or _populateOnce_ | Optional | _ignore_ | Determines the behavior in case that no value is available for the descriptor or tagged value.

* _ignore_: No annotation is created.
* _populateOnce_: A single annotation is created, with the _noValueValue_ being used as value.
| noValueValue | string | Optional | _the empty string_ | If the descriptor or tagged value has no value, then this information item provides the value to use instead (e.g., 0, or true).
| arrayValue | boolean | Optional | _false_ | If true, then the annotation value will always be encoded as an array, even if only a single value is present. Otherwise, the default behavior is to only encode multiple values within a JSON array.
|===

[#table_jsonschema_annotation_element2,reftext='{table-caption} {counter:table-num}']
.ShapeChange JSON Schema annotation element - for annotations with string values, based on templates
[cols="1,1,1,1,6a",options="header"]
|===
| Information Item | Datatype & Structure | Required / Optional | Default Value | Description
| annotation 4+| as defined in the <<table_jsonschema_annotation_element1,previous table>>
| valueTemplate | string | Required | _not applicable_ | Textual template where an occurrence of the field "[[_descriptor-ID_]]" is replaced with the value(s) of that descriptor. The IDs of supported descriptors are listed in the <<table_descriptors,table above>>.

An occurrence of the field "\[[TV:name]]" is replaced with the value(s) of the UML tagged value with the given name from the input schema.

The content of a tagged value can also be split into multiple parts. In that case, use field "[[TV(_separator_):name]]." The tagged value will be split around matches of the given separator (which is treated as a literal).

| noValueBehavior | enum: _ignore_ or _populateOnce_ | Optional | _ignore_ | Determines the behavior in case that no value is available for any of the fields (tagged values and descriptors) contained in the template.

* _ignore_: No annotation is created.
* _populateOnce_: A single annotation is created, with the _noValueValue_ being used for all fields.
| noValueValue | string | Optional | _the empty string_ | If a descriptor used in a template has no value, then this information item provides the value to use instead (e.g., "N/A" or "FIXME").
| arrayValue 4+| as defined in the <<table_jsonschema_annotation_element1,previous table>>
| multiValueBehavior | enum: either _connectInSingleAnnotationValue_ or _createMultipleAnnotationValues_ | Optional | _connectInSingleAnnotationValue_ | Specifies how a case where one or more of the descriptors and tagged values contained in the template have multiple values, shall be encoded.

* _connectInSingleAnnotation_: Multiple values of a descriptor or tagged value contained in the template are combined in a single string value, using the _multiValueConnectorToken_ to connect them.
* _createMultipleAnnotationValues_: Multiple values for one or more descriptor or tagged value result in an array of annotation values, with one value for each combination of multi-valued descriptors / tagged values (resulting in a permutation of the values of each descriptor / tagged value contained in the template).
| multiValue ConnectorToken | string | Optional | _a single space character_ | If a descriptor or tagged value used in the _valueTemplate_ has multiple values, and the _multiValueBehavior_ is set to _connectInSingleAnnotationValue_, then the values are concatenated to a single string value using this token as connector between two values.
|===

NOTE: Conversion rules exist to populate "default" and "readOnly". For further details, see sections <<jsonschema_schemaconversionrules_properties_readonly>> and <<jsonschema_schemaconversionrules_properties_initialvalue>>.

[#example_shapechange_jsonschema_annotation_elements,reftext='{listing-caption} {counter:listing-num}']
.Example of ShapeChange JSON Schema annotation elements
[source,xml,linenumbers]
----
<annotations>
 <JsonSchemaBooleanAnnotation annotation="deprecated" descriptorOrTaggedValue="TV:deprecated"/>
 <JsonSchemaNumberAnnotation annotation="code" descriptorOrTaggedValue="TV:codeNumber"/>
 <JsonSchemaStringAnnotation annotation="title" descriptorOrTaggedValue="alias" noValueBehavior="populateOnce" noValueValue="NA"/>
 <JsonSchemaStringAnnotation annotation="label" descriptorOrTaggedValue="TV(|):aliasList"/>
 <JsonSchemaStringAnnotation annotation="examples" descriptorOrTaggedValue="example" arrayValue="true"/>
 <JsonSchemaTemplateAnnotation annotation="description" valueTemplate="Definition: [[TV:definition]]  Description: [[TV:description]]" noValueValue="[None Specified]"/>
 <JsonSchemaTemplateAnnotation annotation="isDefinedBy" valueTemplate="http://nsgreg.nga.mil/as/view?i=[[TV:itemIdentifier]]"/>
</annotations>

----

[[jsonschema_schemaconversionrules_schemapackage]]
==== Schema Packages

Schema packages have the stereotype \<<applicationSchema>>, \<<schema>>, or an alias (e.g., using a specific language, like \<<anwendungsschema>>). An \<<applicationSchema>> package represents an application schema according to ISO 19109. The stereotype \<<schema>> has been introduced for packages that should be treated like application schemas, but do not contain feature types.

[[jsonschema_schemaconversionrules_schemapackage_definitions]]
===== Definitions Schema

// implementation status: definitions schemas are created, also using "$defs" or "definitions" depending on the schema version - no class schemas yet

A UML application schema and its classes are converted into one or more so-called _definitions schemas_. A definitions schema is a JSON Schema that has the "$defs" keyword.

NOTE: In the JSON Schema specification draft, version 07, the keyword of the definitions section was "definitions". In JSON Schema specification draft, version 2019-09, the keyword was changed to "$defs."

The "$defs" keyword has a JSON object as value, where each member represents the JSON Schema definition of a class from the application schema.

[#example_jsonschema_definitions_schema,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a definitions schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2019-09/schema",
  "$defs": {
    "Class1": {
      "type": "object",
      "properties": {
        "prop1": {"type": "string"}
      },
      "required": ["prop1"]
    },
    "Class2": {
      "type": "object",
      "properties": {
        "prop2": {"type": "number"}
      },
      "required": ["prop2"]
    }
  }
}
----

NOTE: The current definitions schema examples in this document mostly use "definitions" instead of "$defs." The reason is that most JSON Schema validators support JSON Schema draft-07, but at the time when the examples were developed, these validators did not fully support JSON Schema 2019-09.

By default, a UML application schema is encoded as a single definitions schema. By setting tagged value _jsonDocument_ on subpackages of the schema package, the classes within these packages (as well as subpackages for which the tagged value is not set) will be encoded in additional definitions schemas.

NOTE: Tagged value _jsonDocument_ can also be set on the schema package itself, to define the file name of the definitions schema that will be produced for the schema package. If tagged value _jsonDocument_ is not defined for the schema package, or does not have a value, then ShapeChange will use the package name as fallback, replacing all spaces and forward slashes with underscores, and appending '.json'. For example, if a schema package was named 'Ba / nanas' then the file name would be 'Ba___nanas.json'.

[NOTE]
======
If the conversion process does not add any actual definitions to a definitions schema, then that schema will not be written by ShapeChange. Reasons for no definition being added to a definitions schema are:

* The package represented by the definitions schema is empty;
* No type is directly defined in the package, and subpackages with types have their own definitions schema; and/or
* None of the types whose definition would be added to the definitions schema is actually encoded. That can be the case if a type is of a category that is not encoded by default (e.g., a union), and no conversion rule for converting the type is included in the encoding rule. Another case would be that the <<jsonschema_schemaconversionrules_additionalrules,rule to not encode a type >> (_rule-json-all-notEncoded_) applies to the model element.

======

<<img_json_schema_structure_uml_example>> provides an example of a UML application schema, where the tagged value is set both on the schema package itself and on one of its leaf packages. <<img_json_schema_structure>> illustrates the structure of the resulting definitions schemas.

[#img_json_schema_structure_uml_example,reftext='{figure-caption} {counter:figure-num}']
.Example of a UML application schema with tagged value jsonDocument set
image::images/uml_for_definitions_schema_example.png[align="center"]

[#img_json_schema_structure,reftext='{figure-caption} {counter:figure-num}']
.Deriving JSON Schemas from an application schema
image::images/definitions_schemas.png[align="center"]

References from types of the application schema to other types (within the same or within an external schema) are converted as references to the according definitions schemas, using the JSON Schema keyword "$ref" - see <<img_json_schema_references_between_definitions_schemas>>.

[#img_json_schema_references_between_definitions_schemas,reftext='{figure-caption} {counter:figure-num}']
.References between JSON Schemas using $ref
image::images/references_between_definitions_schemas.png[align="center"]

A link to a particular definition within a definitions schema requires the use of a JSON Pointer or an anchor in the fragment identifier of the link URL.

https://tools.ietf.org/html/rfc6901#section-6[JSON Pointer], chapter 6, explicitly states that the media type in which a JSON value is provided needs to support this kind of fragment identifier, and that this is not the case for the media type application/json. If a JSON Schema was published with this media type, then it is possible that the application ignores a fragment identifier (because the media type does not support fragment identifiers).

Definitions schemas therefore should not be published under media type application/json. Instead, a JSON Schema should be published with media type application/schema+json - which is defined by the JSON Schema specification. The media type application/schema+json supports JSON Pointers and plain names as fragment identifiers. For further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02#section-5[JSON Schema core, chapter 5].

[[jsonschema_schemaconversionrules_schemapackage_definitions_noteoninstancevalidation]]
[NOTE]
======
The JSON Schema that shall be used to validate a JSON document cannot be identified within that document itself. In other words, JSON Schema does not define a concept like an xsi:schemaLocation, which is typically used in an XML document to reference the applicable XML Schema(s). Instead, JSON Schema uses link headers and media type parameters to tie a JSON Schema to a JSON document (for further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02[JSON Schema core], sections 11.1 and 11.2). The relationship between a JSON document and the JSON Schema for validation can also be defined explicitly by an application.
======

[[jsonschema_schemaconversionrules_schemapackage_schemaversion]]
===== JSON Schema Version

// implementation status: implemented

According to https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.1.1[JSON Schema core], section 8.1.1, the root schema of a JSON Schema document should contain a "$schema" keyword. The value of this keyword identifies the JSON Schema meta-schema against which the schema is valid. Typically, that is a meta-schema defined by a specific version of the JSON Schema specification.

The "$schema" keyword is therefore added to the definitions schema. Its value is defined via the ShapeChange JSON Schema target configuration parameter _jsonSchemaVersion_. The values supported for the parameter are:

* "2019-09" (the default value of the parameter) - corresponding to the schema URI "https://json-schema.org/draft/2019-09/schema"
* "draft-07" - corresponding to the schema URI "http://json-schema.org/draft-07/schema#"
// * "OpenApi30" - with no schema URI; introduced to support the OpenAPI 3.0 Schema object, which will become obsolete once OpenAPI 3.1 has been adopted (for further details, see <<json_schema_variants>>)

NOTE: The ShapeChange JSON Schema target supports both JSON Schema 2019-09, and the older draft 07, because implementation support for the latter was more prevalent at the time when the JSON Schema work was conducted in UGAS-2020.

NOTE: The "$schema" of the definitions schema examples in this document is mostly set to "http://json-schema.org/draft-07/schema#." The reason is that most JSON Schema validators support JSON Schema draft-07, but at the time when this chapter was written they did not fully support JSON Schema 2019-09.

[[jsonschema_schemaconversionrules_schemapackage_schemaidentifier]]
===== Schema Identifier

// implementation status: implemented

According to https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2.1[JSON Schema core], section 8.2.2.1, the root schema of a JSON Schema document should contain an "$id" keyword with an absolute URI. The "$id" identifies the schema resource with its canonical URI.

NOTE: The URI is an identifier and not necessarily a resolvable URL. If the "$id" is a URL, there is no expectation that the JSON Schema can be downloaded at that URL. However, it is recommended that the URL is stable, persistent, and globally unique.

The definitions schemas derived from the application schema package thus each receive a unique "$id." The value of this id uses the following URI template.

[source]
----
{jsonBaseUri}/{jsonDirectory}/{jsonDocument}
----

Where:

* _{jsonBaseUri}_ is either specified via tagged value _jsonBaseUri_ on the application schema package, or defined via the ShapeChange JSON Schema target configuration parameter _jsonBaseUri_ (which has default value "http://example.org/FIXME"). If both are defined, the tagged value takes precedence over the configuration parameter.
* [[jsonschema_schemaconversionrules_schemapackage_schemaidentifier_jsonDirectory]]_{jsonDirectory}_ is the value of the tagged value of the same name on the application schema package. If that tagged value is undefined, the value of the _xmlns_ tagged value is used. If that tagged value is also not defined, then the string _default_ is used.
* _{jsonDocument}_ is the file name of the definitions schema, which is either defined in the UML model using tagged value of the same name on a package, or automatically derived from the application schema name.

Example: With _jsonBaseUri_ = `https://example.org`, _jsonDirectory_ = `json/schemas/schemaX/1.0`, and _jsonDocument_ = `testschema.json`, ShapeChange will produce:
[source]
----
"$id": "https://example.org/json/schemas/schemaX/1.0/testschema.json"
----

NOTE: The "$id" of the definitions schema is not included in other examples within this chapter, because declaring an absolute, non-existent URL in these examples often prevents JSON Pointers from these examples from working when testing the examples, for instance on https://www.jsonschemavalidator.net/ (which is a useful tool for testing JSON Schema).

[[jsonschema_schemaconversionrules_types]]
==== Types

[[jsonschema_schemaconversionrules_types_mappings]]
===== Mappings

// implementation status: implemented

Application schemas typically use types from other schemas, for example the types defined by ISO 19103 and ISO 19107. External types can be used as value types of properties, and as supertypes for types defined in the application schema that is being converted.

Whenever an external type is used, its JSON Schema definition is needed. Either an external type is implemented as one of the simple JSON value types (e.g., string - maybe with a certain format), or it is defined by a particular JSON Schema. In case of a JSON Schema, the URL of that schema needs to be known during the conversion process. If the schema is a definitions schema, then the URL needs to be augmented with a fragment identifier that includes a JSON Pointer or an anchor reference within the schema.

Information about the JSON Schema implementation of external types must explicitly be provided to the ShapeChange JSON Schema target via so called map entries. These map entries are part of the target configuration. A map entry of the JSON Schema target must:

* identify the schema type that is being mapped, by name
* define the JSON Schema implementation of that type:
** either as one of the few simple JSON value types (string, number, integer, boolean), potentially with additional keywords conveyed via map entry parameter:
*** for any simple JSON value type: keyword _format_
*** for JSON value type _string_: keywords _enum_, _const_, _pattern_, _maxLength_, _minLength_
**** NOTE: Complex regular expressions intended to be used as _pattern_ may need to be base64 encoded, in order to avoid problems with syntax rules of the map entry parameter. For base64 encoded regular expressions, use the _patternBase64_ characteristic of the ShapeChange map entry parameter _keywords_.
*** for JSON value types _integer_ and _number_: keywords _enum_, _const_, _multipleOf_, _maximum_, _minimum_, _exclusiveMaximum_, _exclusiveMinimum_
** or as a URL that references the JSON Schema definition of the external type
* declare the path to the JSON member that is used to encode the name of the type that the JSON object represents, (e.g., "type", "entityType", or "properties/observationType") - if such a member exists in the target type
** This information is useful to support specialization (for further details, see <<jsonschema_schemaconversionrules_types_inheritance_specialization>>) and encoding <<jsonschema_schemaconversionrules_properties_valuetype_valuetypeoptions,value type options>>.

// The <<profiles>> chapter documents a core profile of ISO schemas that are used in the NSG, as well as the JSON Schema definitions for the types contained in that profile. In UGAS-2020, type mappings have been created for this profile, in order to create a NAS JSON Schema. The mappings can also be used for the conversion of other application schemas.

//////

[[jsonschema_schemaconversionrules_types_classschema]]
===== Class Schema

// implementation status: not implemented (because still TBD)

With __rule-json-cls-class-schemas__, a JSON Schema document - in this document called _class schema_ - is created for each type that is being converted. The class schema contains a reference ("$ref") to the full JSON Schema definition within the definitions schema.

The benefit of producing such a schema is that this schema can be identified and referenced - from other schemas or as a link header from a JSON instance document - using a simple URI without fragment identifier. In contrast: in order to refer to a particular definition contained within a definitions schema, the URI must include a fragment identifier.

#TBD: Not sure, if the benefit is really that great. The effort required to implement class schemas does not appear to be worth it. However, maybe such schemas would be easier to configure in web servers that publish JSON data? If we decide against implementing this rule, we will update the ER to remove any mentions of "class schema" (also in figures). That primarily affects the <<jsonschema_schemaconversionrules_schemapackage>> section.#

The JSON Schema version of a class schema is determined like it is done for the application schema package (see <<jsonschema_schemaconversionrules_schemapackage_schemaversion>>).

The "$id" of the class schema has the following structure:

[source,]
----
<base-URI>/<subdirectory>/<type-name>.json
----

Where:

* <base-URI> and <subdirectory> are as defined in the <<jsonschema_schemaconversionrules_schemapackage_schemaidentifier>> section
* <type-name> is the name of the type that is being converted

//////

[[jsonschema_schemaconversionrules_types_classname]]
===== Class Name

The following use cases have been identified where converting the name of a type is useful:

* Defining location independent identifiers within the definitions schema, to create simple references to schema definitions.
* Supporting type identification, thereby enabling at least some level of type inheritance checks and semantic mapping.

[[jsonschema_schemaconversionrules_types_classname_anchor]]
====== Location Independent Schema Identifiers

// implementation status: implemented

With __rule-json-cls-name-as-anchor__, the name of a class is encoded as an "$anchor," which is added at the start of the schema definition of the class (within the definitions schema). Schema definitions that have an "$anchor" can be referenced using the plain text value of the anchor as fragment identifier, instead of using a more complex JSON Pointer.

NOTE: The "$anchor" keyword was added in JSON Schema draft 2019-09. It replaces the somewhat ambiguous use of the "$id" keyword in JSON Schema draft 07 to define plain name fragment identifiers for subschemas. For further details, see section 8.2.3 of both https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.3[JSON Schema draft 2019-09] and  https://tools.ietf.org/html/draft-handrews-json-schema-01#section-8.2.3[JSON Schema draft 07].

[#example_jsonschema_types_classname_anchor,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema (version 2019-09) example of location independent schema identifiers
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2019-09/schema",
  "$defs": {
    "TypeA": {
      "$anchor": "TypeA",
      "...": "..."
    },
    "TypeB": {
      "$anchor": "TypeB",
      "...": "..."
    }
  }
}
----

If the ShapeChange target parameter _jsonSchemaVersion_ (see <<jsonschema_schemaconversionrules_schemapackage_schemaversion>>) is set to "draft-07," then __rule-json-cls-name-as-anchor__ results in the creation of the "$id" keyword, instead of the "$anchor" keyword.

NOTE: JSON Schema draft 07 requires the value of "$id" to start with "\#", thus when producing a JSON Schema compliant to JSON Schema draft 07, the combination of "#" and the class name is used as value of the "$id" key.

[#example_jsonschema_types_classname_anchor_draft07,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema (draft 07) example of location independent schema identifiers
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "$id": "#TypeA",
      "...": "..."
    },
    "TypeB": {
      "$id": "#TypeB",
      "...": "..."
    }
  }
}
----


[[jsonschema_schemaconversionrules_types_classname_typeidentification]]
====== Type Identification

// implementation status: implemented

__rule-json-cls-name-as-entityType__ adds another JSON member to the JSON object which represents the class that is being converted.

The name of the JSON member can be configured using the ShapeChange JSON Schema target parameter __entityTypeName__. The default value of the parameter is "entityType". The JSON member is required and string-valued. It should be used to encode the name of the type that is represented by the JSON object.

NOTE: By default, the property value is not restricted using "const", because doing so would prevent JSON Schema constraints that support inheritance-related checks. However, if the application schema did not use inheritance, then such restrictions could be defined.

[#example_jsonschema_types_classname_typeidentification,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example with property "entityType" used for identifying the type of a JSON object
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "property": {
          "type": "string"
        }
      },
      "required": [
        "entityType", "property"
      ]
    }
  },
  "$ref": "#/definitions/Type"
}
----

The following JSON instance is valid against the schema:

[source,json,linenumbers]
----
{
  "entityType": "Type",
  "property": "x"
}
----

Encoding the type name in JSON objects is useful.

* Encoding the type of a JSON object together with its other properties supports a more complete validation of property values, where the property type is a supertype. For further details, see <<jsonschema_schemaconversionrules_properties_valuetype>>.
* As described in http://docs.opengeospatial.org/per/18-091r2.html#JSON_LD[chapter 6 of the OGC Testbed-14: Application Schemas and JSON Technologies Engineering Report], having a key within a JSON object with a string value that identifies the type of the object allows that object to be mapped to RDF. More specifically, the string value can be mapped to an IRI that identifies the type of an RDFS resource.

There are also some cases in which __rule-json-cls-name-as-entityType__ is ignored or conditional.

* To prevent the addition of unnecessary JSON members (here: because the JSON member would already be inherited), the rule is ignored for a type T if T is a subtype and __rule-json-cls-name-as-entityType__ already applies to one of its supertypes.
* By default, the rule does not apply to unions, enumerations, and code lists. +
+
However, if __rule-json-cls-name-as-entityType-union__ is enabled together with __rule-json-cls-name-as-entityType__, then the latter also applies to unions. The considerations that led to the addition of the former conversion rule are: Unions can be converted to JSON objects (see <<jsonschema_schemaconversionrules_types_union>>, more specifically: <<jsonschema_schemaconversionrules_types_union_propertychoice>>). The https://shapechange.net/targets/ontology/uml-rdfowl-based-isois-19150-2/[ontology target of ShapeChange] encodes a union as a class, with cardinality restrictions to ensure that only one option (defined by the union) is used. For further details, also see the http://docs.opengeospatial.org/per/16-020.html#rdf_cr_class_union[OGC Testbed-12 ShapeChange Engineering Report]. This is an argument for applying __rule-json-cls-name-as-entityType__ to unions, because it would support a JSON-LD based mapping to the union class in RDF/OWL.

[[jsonschema_schemaconversionrules_types_abstractness]]
===== Abstractness

// implementation status: nothing to do

JSON Schema does not directly support abstractness. An abstract class is therefore encoded like a non-abstract class.

NOTE: Encoding a JSON object that represents an abstract type, with the "entityType" having the abstract type name as value, would be useful with regards to linked data applications, and conversion of JSON data to RDF using JSON-LD. Abstractness is also not supported in RDF/OWL, so RDF resources can define the RDFS/OWL class or datatype, which represent an abstract type from the conceptual model, as their type. That makes sense for cases in which the exact type of a resource or "thing" is not known yet, but a more general type is.

[[jsonschema_schemaconversionrules_types_inheritance]]
===== Inheritance

JSON Schema does not support the concept of inheritance itself. A workaround for this issue would be to transform the conceptual model and flatten all inheritance hierarchies. For further details, see <<jsonschema_transformationrules_inheritance>>.

The following sections document the conversion of an inheritance relationship, covering the topics of <<jsonschema_schemaconversionrules_types_inheritance_generalization>> and  <<jsonschema_schemaconversionrules_types_inheritance_specialization>>. A special case of generalization, for classes with specific stereotypes, is discussed in section <<jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships>>.

[[jsonschema_schemaconversionrules_types_inheritance_generalization]]
====== Class Generalization and Property Inheritance

// implementation status: implemented

The generalization relationship of a subtype to its supertype is converted by combining the structural constraints of the subtype and its supertype using the JSON Schema keyword "allOf."

[#img_json_schema_inheritance_generalization_example,reftext='{figure-caption} {counter:figure-num}']
.Example of type inheritance
image::images/Generalization_example.png[align="center"]

[#example_jsonschema_types_inheritance_generalization,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example for realizing generalization using "allOf"
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "properties": {
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "TypeB": {
      "allOf": [
        {
          "$ref": "#/definitions/TypeA"
        },
        {
          "type": "object",
          "properties": {
            "propertyB": {
              "type": "string"
            }
          },
          "required": [
            "propertyB"
          ]
        }
      ]
    }
  },
  "$ref": "#/definitions/TypeB"
}
----

This JSON object is valid against the schema from <<example_jsonschema_types_inheritance_generalization>>:

[source,json,linenumbers]
----
{
  "propertyA": 2,
  "propertyB": "x"
}
----

This JSON object is invalid (because "propertyA" is missing) against the schema from <<example_jsonschema_types_inheritance_generalization>>:

[source,json,linenumbers]
----
{
  "propertyB": "x"
}
----

NOTE: This also works for an encoding where the properties of a class are nested within a key-value pair (like "properties" for a GeoJSON encoding).

NOTE: The case where a property from a supertype is redefined by a property from the subtype is supported. Redefinition in UML requires that the value type of the subtype property is "kind of" the type of the redefined property of the supertype. Therefore, the property value, when encoded in JSON, would satisfy the JSON Schema constraints defined by both the subtype property and the redefined supertype property.

This approach to converting a generalization relationship has the following restrictions.

* The JSON Schema keyword "additionalProperties" must not be set to false in the definitions of both the super- and the subtype.
* The approach only works for generalization relationships of feature, object, and data types. For unions, enumerations, and code lists generalization relationships are not supported.
* It only converts the generalization relationship from subtype to supertype. It does not support the other direction of an inheritance relationship, i.e., specialization. Given a JSON object that encodes a subtype, and the JSON Schema of the supertype, then only the constraints of the supertype are checked, but not all the constraints that apply to the subtype. That is an issue when encoding a UML property whose value type is or could be a supertype (via a subtype that is added by an external, so far unknown schema). Conceptually, the actual value of that property can be a supertype object, but it could just as well be an object whose type is a subtype of that supertype. This issue can only be solved to a certain degree with JSON Schema, as explained in the <<jsonschema_schemaconversionrules_types_inheritance_specialization>> section.

Multiple inheritance is supported by adding all supertypes as elements of "allOf."

[[jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships]]
====== Virtual Generalization

// implementation status: implemented (subtypes don't get the relationship if one of their supertypes has it)

It is often useful to encode all classes with a certain stereotype with a common base type. The generalization relationship to such a base type is often implied with the stereotype, for a given encoding. In GML, for example, the common base type for classes with stereotype \<<featureType>> is gml:AbstractFeature. Rather than explicitly modeling such a base type (e.g., _AnyFeature_ defined by ISO 19109), as well as explicitly modeling generalization relationships to the base type, the encoding rule typically takes care of adding that relationship to relevant schema types.

This kind of virtual generalization is supported via __rule-json-cls-virtualGeneralization__. The rule adds generalization relationships to specific kinds of classes - if a) according ShapeChange JSON Schema target parameters have been set, and b) the class does not already have that generalization relationship via one of its supertypes:

* feature type - configuration parameter _baseJsonSchemaDefinitionForFeatureTypes_
* object type - configuration parameter _baseJsonSchemaDefinitionForObjectTypes_
* data type - configuration parameter _baseJsonSchemaDefinitionForDataTypes_

The parameter value shall be a URI to reference the JSON Schema that defines the common base type. For example, in order for all feature types to use the GeoJSON Feature definition as common base, set `_baseJsonSchemaDefinitionForFeatureTypes_ = https://geojson.org/schema/Feature.json`.

NOTE: Being able to choose any URI as parameter value can be useful for offline and private-network situations.

NOTE: The parameters do not have a default value. If a parameter is not set or does not have a value, then __rule-json-cls-virtualGeneralization__ will not have an effect for the kind of class (feature, object, or data type) for which the parameter applies.

The virtual generalization relationship is implemented by converting the class to a JSON Schema that consists of an "allOf" with two subschemas: the first being a "$ref" with the URI defined by the target parameter, the second being the schema produced by applying the other conversion rules to the class.

The only exception is __rule-json-cls-name-as-anchor__, because the "$anchor" created by that rule is not encoded in the second subschema, but in the schema that contains the "allOf".

[[jsonschema_schemaconversionrules_types_inheritance_specialization]]
====== Class Specialization and Property Ranges

// implementation status: not implemented - on hold until actual need for this kind of validation is expressed by OGC community

By default, validation of a property value encoded in JSON, with the value having a complex type (i.e., being a JSON object or an array of JSON objects), only encompasses checking the JSON Schema constraints defined for that type. If the property value actually is a subtype of that type, then the constraints defined for that subtype would not be checked. Ideally, the constraints of known and unknown subtypes would automatically be checked, but JSON Schema does not support this.

NOTE: If JSON data was transformed to RDF using JSON-LD, then class specialization and property ranges could fully be checked by validating the RDF data using SHACL. 

// For further details, see the <<shacl_shaclconversion>> section of this document.

To a limited extent specialization relationships could be represented in JSON Schema, but only for subtypes in the same schema/model and using complex, verbose constructs from JSON Schema. This would make the schemas hard to read (by humans) and to parse (by application schema parsers in clients). The value of such a capability is therefore questionable and currently not supported.

[NOTE]
====
To capture the discussion, a potential conversion rule is documented below, but has not been implemented in the pilot.

The conversion rule would support known subtypes. "Known" are the subtypes defined in the UML model that contains the application schema from which the JSON Schema is derived.

There would be a limitation that subtypes from different schemas with identical class names, but conflicting definitions (e.g., `SchemaA::ExtensionX.propA` has type `string`, while `SchemaB::ExtensionX.propA` has type `number`) would not be supported.

A pre-condition of the conversion rule would be that the subtype name must be included in the encoding of the JSON object. The conversion rule therefore would require __rule-cls-name-as-entityType__ (see section <<jsonschema_schemaconversionrules_types_classname_typeidentification>>) to be part of the encoding rule with the default name "entityType" - or some alternative mechanism to identify the JSON member that encodes the type.

The definitions schema includes a definition for each type that is being converted. Under the additional conversion rule for specialization, a second definition would be generated for each supertype of the application schema (that is a feature, object, or data type). The name of that definition would be constructed as: `{type-name}_valueType`. If __rule-cls-name-as-anchor__ (see <<jsonschema_schemaconversionrules_types_classname_anchor>>) is also part of the encoding rule, then that name would also be encoded as "$anchor" of the new definition.

The JSON Schema of the new definition would be constructed as follows.

* Determine the list of direct and indirect subtypes. If abstract types are also converted (see <<jsonschema_schemaconversionrules_types_abstractness>>), then abstract subtypes would be included, too.
* Create a sequence of if-then-else expressions, where the if-condition checks the "entityType" against the name of a subtype, the "then" case refers to the JSON Schema definition of that type, and the "else" case represents the if-then-else for the next subtype. The last "else" case refers to the JSON Schema definition of the supertype. <<example_jsonschema_types_inheritance_specialization>> illustrates how this would look like, for the UML model from <<img_jsonschema_valuetype_uml>>.

The resulting JSON Schema looks for an "entityType" match. If one is found, the JSON object is validated against the JSON Schema definition of that type. If no match is found, then the JSON Schema of the supertype is used as a fallback for validation. The JSON object would then at least have to fulfill the constraints defined by the schema of the supertype. However, any additional content of the JSON object would not be validated.

[#img_jsonschema_valuetype_uml,reftext='{figure-caption} {counter:figure-num}']
.Example of a value type being a supertype
image::images/Specialization_example.png[align="center"]

[#example_jsonschema_types_inheritance_specialization,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a value type definition for a supertype
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "entityType",
        "propertyA"
      ]
    },
    "TypeA_valueType": {
      "if": {
        "properties": {
          "entityType": {
            "const": "TypeB"
          }
        }
      },
      "then": {
        "$ref": "#/definitions/TypeB"
      },
      "else": {
        "$ref": "#/definitions/TypeA"
      }
    },
    "TypeB": {
      "allOf": [
        {
          "$ref": "#/definitions/TypeA"
        },
        {
          "type": "object",
          "properties": {
            "entityType": {
              "type": "string"
            },
            "propertyB": {
              "type": "string"
            }
          },
          "required": [
            "entityType",
            "propertyB"
          ]
        }
      ]
    },
    "TypeC": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "propertyC": {
          "$ref": "#/definitions/TypeA_valueType"
        }
      },
      "required": [
        "entityType",
        "propertyC"
      ]
    }
  },
  "$ref": "#/definitions/TypeC"
}
----

The following two JSON objects are valid against the schema from <<example_jsonschema_types_inheritance_specialization>>:

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "TypeA",
    "propertyA": 3
  }
}
----

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "TypeB",
    "propertyA": 3,
    "propertyB": "x"
  }
}
----

The next JSON object is also valid against the schema from <<example_jsonschema_types_inheritance_specialization>>, because the value of "propertyC" matches the schema of supertype TypeA, even though the entity type is unknown:

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "UnknownExtensionTypeA",
    "propertyA": 3
  }
}
----

The following two JSON objects are invalid against the schema from <<example_jsonschema_types_inheritance_specialization>> (in both cases because the type of "propertyA" is string instead of number):

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "TypeB",
    "propertyA": "y",
    "propertyB": "x"
  }
}
----

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "UnknownExtensionTypeB",
    "propertyA": "z"
  }
}
----

Note that if the last else-case simply was 'false', then that would prevent any unknown subtype from being encoded - at least with the value type definition created and used within the definitions schema that is being produced. For a non-abstract supertype, the if-then-else construct would then have to contain an additional `if (entityType=Supertype) then $ref: schemaSupertype` - before the case of "else false."

// Map entries will need to identify the object property that encodes the entity type. If no such property  is  available  for  a  specific  type,  ShapeChange  should  log  a  warning  that  the  rule  cannot cover the case of that type.

====

[[jsonschema_schemaconversionrules_types_featureandobjecttype]]
===== Feature and Object Type

In the conceptual model, feature and object types represent objects that have identity. That differentiates these types from, for example, data types. Other than that, feature and object types are encoded as JSON objects, just like a data type.

A feature or object type - in the following summarily called types with identity - is converted to a JSON Schema definition which is added to the definitions schema, using the type name as definition key. Note that ISO 19109 requires class names to be unique within the scope of an application schema.

The conversion of the class properties is defined in the <<jsonschema_schemaconversionrules_properties>> section. General type conversion rules, such as those documented in the <<jsonschema_schemaconversionrules_types_classname>> section, may apply. Additional conversion rules and behavior for types with identity are described in the following sections.

[[jsonschema_schemaconversionrules_types_featureandobjecttype_identifier]]
====== Identifier

// implementation status: implemented

The conceptual model of a type with identity often does not contain a property whose value is used by applications to identify objects of that type. Instead, the according information is added or defined in platform specific encodings. For example, a GML application schema offers the gml:id attribute as well as the gml:identifier element to encode identifying information.

In a web publishing context, the URI at which a JSON object is published can be used as its identifier. Therefore, the default behavior of the ShapeChange JSON Schema target is to not add an identifier property. However, in many applications it is useful to have a member within a JSON object that provides the identifier of that object. Existing specifications often include such a capability, e.g., the "id" member in GeoJSON or "@id" in JSON-LD.

With __rule-json-cls-identifierForTypeWithIdentity__, an identifier JSON member will be added to the JSON object that represents the type with identity. The key, and value type of that member can be configured using ShapeChange JSON Schema target parameters:

* __objectIdentifierName__: "id" (the default) or any other suitable string that does not conflict with other member names);
* __objectIdentifierType__: "string" (the default), "number", or "string, number";

// "string, number" because GeoJSON does it that way

* __objectIdentifierRequired__: "false" (the default) or "true" is used to define if the property is required or optional.

[#example_jsonschema_types_featureandobjecttype_identifier,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a feature type with a required identifier property "id"
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "entityType",
        "id",
        "propertyA"
      ]
    }
  },
  "$ref": "#/definitions/TypeA"
}
----

The following JSON object is valid against the schema from <<example_jsonschema_types_featureandobjecttype_identifier>>:

[source,json,linenumbers]
----
{
  "entityType": "TypeA",
  "id": "42445fdasd7asd6f7",
  "propertyA": 3
}
----

__rule-json-cls-identifierForTypeWithIdentity__ is ignored if one of the following conversion rules is part of the encoding rule as well:

* __rule-json-cls-identifierStereotype__ - This conversion rule assumes that all types with identity have an attribute with stereotype \<<identifier>> (directly, or inherited from a supertype). That attribute is used to encode the identifier. +
+
NOTE: If the maximum multiplicity of an \<<identifier>> attribute is greater than 1, ShapeChange will log an error.

* __rule-json-cls-ignoreIdentifier__ - With this rule, the identifier of a type with identity will be encoded using an identifier member that is provided by a common base type (e.g., the "id" member of a GeoJSON Feature, to which a generalization relationship exists for a given feature type - see <<jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships>>). That means that no additional identifier property is created. __rule-json-cls-identifierForTypeWithIdentity__ is therefore overridden by __rule-json-cls-ignoreIdentifier__. Also, all identifier properties that are identified by __rule-json-cls-identifierStereotype__ - if also included in the encoding rule - will simply be ignored when encoding the type with identity. +
+
NOTE: The https://geojson.org/schema/Feature.json[JSON Schema for a GeoJSON Feature] does not include "id" (which is defined in the https://tools.ietf.org/html/rfc7946#section-3.2[GeoJSON standard, section 3.2]) - not even as optional property of a "Feature". A PullRequest has been created which would fix this, see https://github.com/geojson/schema/pull/9, but it has not been merged (as of March 11, 2020).

To prevent the addition of unnecessary JSON members (here: because the JSON member would already be inherited), __rule-json-cls-identifierForTypeWithIdentity__ is ignored for a type T if T is a subtype and __rule-json-cls-identifierForTypeWithIdentity__ already applies to one of its supertypes.

[[jsonschema_schemaconversionrules_types_featureandobjecttype_nestedproperties]]
====== Nested Properties

// implementation status: implemented

By default, the properties of a type are converted to first-level properties of the resulting JSON object. In GeoJSON, feature properties are encoded within the GeoJSON "properties" member. Notable exceptions from that rule are the GeoJSON members "id," "geometry," and "bbox." In order to produce a JSON Schema that converts the properties of a type with identity to be encoded within a nested "properties" member - minus any properties that are mapped to the other aforementioned GeoJSON keys - the conversion rule __rule-json-cls-nestedProperties__ needs to be included in the encoding rule.

NOTE: <<example_jsonschema_encrule_geojson>> illustrates the result of applying __rule-json-cls-nestedProperties__, given the feature type in <<img_jsonschema_encrule_geojson_uml>>.

[[jsonschema_schemaconversionrules_types_datatype]]
===== Data Type

// implementation status: implemented

A \<<dataType>> is converted to the JSON Schema definition of a JSON object. The properties of the data type are converted to the properties of that object, as described in the <<jsonschema_schemaconversionrules_properties>> section.

[[jsonschema_schemaconversionrules_types_mixin]]
===== Mixin Type

// implementation status: implemented

ShapeChange supports the notion of mixin type (for further details, see http://shapechange.net/targets/xsd/extensions/mixin/). They are primarily used by the XML Schema target. However, if that target is contained in the ShapeChange configuration, it has implications on how UML types are loaded. In this case, it may lead to UML types being loaded as mixin types. A UML type is loaded as a mixin type if:

* __rule-xsd-cls-mixin-classes__ is contained in the XSD encoding rule and:
** the tagged value _gmlMixin_ is set to true, or
** The type has the stereotype \<<type>>, is abstract, and the tagged value _gmlMixin_ is not set to false.

For the JSON Schema conversion rules, a mixin type is treated like a data type.

[[jsonschema_schemaconversionrules_types_union]]
===== Union

// implementation status: implemented

Application schemas have two ways of using types with stereotype \<<union>>.

* According to ISO 19103:2015, a \<<union>> type consists __"of one and only one of several alternative datatypes (listed as member attributes). This is similar to a discriminated union in many programming languages"__. According to this definition, only the types of the UML attributes defined for a \<<union>> are of interest.
* In practice, unions defined in application schemas can also have another use: they define a choice between a number of options, where each option is defined by a UML attribute. In other words, the attribute itself has meaning (not just its value type). Multiple options can have the same value type. The UML-to-GML application schema encoding rules support this way of using unions (see OGC 07-036r1, section E.2.4.10).

The following sections document the conversion rules that support these two approaches of using unions.

[[jsonschema_schemaconversionrules_types_union_propertychoice]]
====== Property Choice

// implementation status: implemented

__rule-json-cls-union-propertyCount__ encodes a choice between the properties - i.e., the options - defined by a \<<union>>.

The \<<union>> is converted to the JSON Schema definition of a JSON object. Each union option is represented as an optional member of the JSON object. The choice between the options defined by the union is encoded using "maxProperties" = "minProperties" = 1. That is, the number of members that are allowed for the JSON object is restricted to exactly one.

An `"additionalProperties": false` is used to prevent any undefined properties. The result of applying these rules to the union from <<img_jsonschema_union_example>> is shown in <<example_jsonschema_union_minMaxProperties>>.

[#img_jsonschema_union_example,reftext='{figure-caption} {counter:figure-num}']
.\<<union>> example
image::images/Union_example.png[align="center"]

[#example_jsonschema_union_minMaxProperties,reftext='{listing-caption} {counter:listing-num}']
.Example of a JSON Schema for a \<<union>> class, representing the property choice using "minProperties" and "maxProperites"
[source,json, linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "UnionA": {
      "type": "object",
      "properties": {
        "option1": {
          "type": "string"
        },
        "option2": {
          "type": "number"
        }
      },
      "additionalProperties": false,
      "minProperties": 1,
      "maxProperties": 1
    }
  },
  "$ref": "#/definitions/UnionA"
}
----

NOTE: An alternative approach would be using the "oneOf" keyword, with one subschema per union property, which only defines that property, and requires it (but does not perform any other checks). This option is more verbose, harder to read and understand and, therefore, not implemented.

This JSON object is valid against the schema from <<example_jsonschema_union_minMaxProperties>>:

[source,json,linenumbers]
----
{
  "option1": "x"
}
----

This JSON object is invalid (because "option2" has a string value, rather than a numeric value) against the schema from <<example_jsonschema_union_minMaxProperties>>:

[source,json,linenumbers]
----
{
  "option2": "x"
}
----

[[jsonschema_schemaconversionrules_types_union_typediscriminator]]
====== Type Discriminator

// implementation status: implemented

__rule-json-cls-union-typeDiscriminator__ encodes a type discriminator defined by a \<<union>>.

The \<<union>> is converted to a JSON Schema definition that represents a choice between the value types of the union properties.

* If the value types are only simple, without a specific format definition or other restrictions defined by JSON Schema keywords, then the JSON Schema will only contain a "type" member, with an array of the simple types.
* Otherwise, a "oneOf" member is added to the JSON Schema definition, with:
** one "$ref" per non-simple type,
** one "type" for all simple types without specific keywords, and
** one "type" per simple type with specific keywords.

The result of applying the rule to the union from <<img_jsonschema_type_discriminator_union_example>> is shown in <<example_jsonschema_union_minMaxProperties>>.

[#img_jsonschema_type_discriminator_union_example,reftext='{figure-caption} {counter:figure-num}']
.Example of type discriminator unions
image::images/type_discriminator_unions.png[align="center"]

[#example_jsonschema_union_type_discriminator,reftext='{listing-caption} {counter:listing-num}']
.Example of a JSON Schema for unions, encoding them as type discriminators
[source,json, linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Union_TypeDiscriminator": {
      "oneOf": [
        {
          "type": [
            "string",
            "integer"
          ]
        },
        {
          "$ref": "https://geojson.org/schema/Point.json"
        },
        {
          "type": "string",
          "format": "date"
        }
      ]
    },
    "Union_TypeDiscriminator_OtherTypes": {
      "oneOf": [
        {
          "$ref": "https://geojson.org/schema/LineString.json"
        },
        {
          "$ref": "https://geojson.org/schema/Point.json"
        }
      ]
    },
    "Union_TypeDiscriminator_SimpleTypes": {
      "type": [
        "string",
        "integer"
      ]
    }
  }
}
----

[[jsonschema_schemaconversionrules_types_enumeration]]
===== Enumeration

// implementation status: implemented

An \<<enumeration>> is converted to a JSON Schema definition with a type defined by evaluating tagged value _literalEncodingType_. In addition, it uses the "enum" keyword to restrict the value to one of the enums from the enumeration.

The tagged value _literalEncodingType_ identifies the conceptual type that applies to the enumeration values. If the tagged value is not set on the enumeration, or has an empty value, then the literal encoding type is set to be CharacterString. The literal encoding type is mapped to a JSON Schema type. The result should be a simple JSON Schema type (string, number, integer, or boolean). The enumeration values will be encoded accordingly.

[#img_jsonschema_enumeration_example,reftext='{figure-caption} {counter:figure-num}']
.\<<enumeration>> example
image::images/Enumeration_example.png[align="center"]

[#example_jsonschema_enumeration,reftext='{listing-caption} {counter:listing-num}']
.Example of enumerations encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Enumeration1": {
      "type": "number",
      "enum": [-5, 0, 5.5]
    },
    "Enumeration2": {
      "type": "string",
      "enum": ["A","B","C"]
    }
  },
  "anyOf": [
    {"$ref": "#/definitions/Enumeration1"},
    {"$ref": "#/definitions/Enumeration2"}
  ]
}
----

[[jsonschema_schemaconversionrules_types_codelist]]
===== Code List

// implementation status: implemented

By default, a \<<codelist>> is converted to a JSON Schema definition with a type defined by evaluating tagged value _literalEncodingType_.

The tagged value _literalEncodingType_ identifies the conceptual type that applies to the code values. If the tagged value is not set on the code list, or has an empty value, then the literal encoding type is set to be CharacterString. The literal encoding type is mapped to a JSON Schema type. The result should be a simple JSON Schema type (string, number, integer, or boolean).

With __rule-json-cls-codelist-uri-format__, all code lists will be represented by a JSON Schema that restricts the type to "string", and states that the "format" is "uri" (as defined by https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7.3.5[JSON Schema validation, section 7.3.5]).

With __rule-json-cls-codelist-link__, all code lists will be represented by a JSON Schema that restricts the type to a http://schemas.opengis.net/ogcapi/features/part1/1.0/openapi/schemas/link.yaml["Link" object] as specified by IETF RFC 8288 and implemented in the OGC API standards. The Link object provides "href" and "title" members like the simple Xlinks in GML.

NOTE: The URL to the JSON Schema of the "Link" object (as shown in <<example_jsonschema_link_object>>) can be configured using the ShapeChange JSON Schema target parameter _linkObjectUri_.

[#example_jsonschema_link_object,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema of the "Link" object
[source,json,linenumbers]
----
include::code/link.json[]
----

In <<img_jsonschema_codelist_example>>, the encoding rule for code list "CodelistLinkObject" contains __rule-json-cls-codelist-link__, whereas the encoding rule for code list "CodelistUriFormat" contains __rule-json-cls-codelist-uri-format__, and the encoding rule for the remaining two code lists contains none of these conversion rules. The resulting JSON Schema is shown in <<example_jsonschema_codelist>>.

[#img_jsonschema_codelist_example,reftext='{figure-caption} {counter:figure-num}']
.\<<codeList>> example
image::images/Codelist_example.png[align="center"]

[#example_jsonschema_codelist,reftext='{listing-caption} {counter:listing-num}']
.Example of code lists encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "CodelistLinkObject": {
      "$ref": "http://example.org/jsonschema/link.json"
    },
    "CodelistNumeric": {
      "type": "number"
    },
    "CodelistString": {
      "type": "string"
    },
    "CodelistUriFormat": {
      "type": "string",
      "format": "uri"
    }
  }
}
----

NOTE: A string based code list conversion is better suited for a subsequent mapping of JSON encoded code values to RDF using JSON-LD. 

// For further details, see the future work item <<overview_future_work_jsontordf>>.

[[jsonschema_schemaconversionrules_types_basictype]]
===== Basic Type

// implementation status: implemented

If a direct or indirect supertype of an application schema class is mapped to one of the simple JSON Schema types _string_, _number_, _integer_, or _boolean_, then under __rule-json-cls-basictype__ that class represents a so called _basic type_.

A basic type does not define a JSON object. It represents a simple data value, e.g., a string. The JSON Schema definition of a basic type thus defines a simple JSON Schema type. A basic type can be restricted using a number of JSON Schema keywords. <<table_basictypes_restrictions>> defines which tagged values can be used to define these restrictions for a basic type, and which restrictions are available for which simple JSON Schema type.

[#table_basictypes_restrictions,reftext='{table-caption} {counter:table-num}']
.Basic type restrictions
[options="header"]
|====================
| JSON Schema keyword | tagged value to define the restriction | applicable JSON Schema type(s)
| format | _jsonFormat_ | string, number, integer
| maxLength | _length_, _maxLength_, or _size_ | string
| pattern | _jsonPattern_ | string
| minimum +
(inclusive) | _rangeMinimum_ | number, integer
| maximum +
(inclusive) | _rangeMaximum_ | number, integer
|====================

NOTE: The JSON Schema keyword "format" is defined in chapter 7 of <<ref_jsonschema_02_validation,JSON Schema Validation: A Vocabulary for Structural Validation of JSON>>. The formats defined there (e.g., "date-time", "uri", and "json-pointer") apply to JSON values of type string. Custom formats could apply to JSON values of type number and integer.

NOTE: <<ref_jsonschema_02_validation,JSON Schema Validation: A Vocabulary for Structural Validation of JSON>> defines the JSON Schema keyword "pattern". According to that specification, the value of the keyword should be a regular expression according to the ECMA 262 regular expression dialect. However, the specification does not reference a particular version or edition of ECMA 262. The regular expression dialect to be used in a JSON Schema "pattern" therefore is not exactly defined, and consequently depends on the implementation of a JSON Schema validator. In order to avoid issues with this diversity, <<ref_jsonschema_02,JSON Schema: A Media Type for Describing JSON Documents>> defines a number of recommendations for writing regular expressions in JSON Schema.

[NOTE]
======
The regular expression dialect used by JSON Schema is the one used by ECMA 262 (though, as said before, no specific version or edition of that standard is referenced by JSON Schema). It is unlikely that this dialect will ever be the same as https://www.w3.org/TR/xmlschema11-2/#regexs[the one used by XML Schema 1.1], which is for example used in XML Schema to define the https://www.w3.org/TR/xmlschema11-2/#rf-pattern[pattern facet]. XML Schema conversion rules supported by ShapeChange (https://shapechange.net/targets/xsd/extensions/#rule-xsd-prop-constrainingFacets[rule-xsd-prop-constrainingFacets] and https://shapechange.net/targets/xsd/extensions/#rule-xsd-prop-length-size-pattern[rule-xsd-prop-length-size-pattern]) use tagged value _pattern_ to define the regular expression for the pattern facet in the XML Schema encoding. Due to the differences in regular expression dialects used by JSON Schema and XML Schema, __rule-json-cls-basictype__ uses a different tagged value, namely _jsonPattern_, to define the regular expression for the "pattern" keyword in a JSON Schema. If the regular expression for a basic type must be different, in order to be valid in XML Schema and in JSON Schema, then both tagged value _pattern_ and _jsonPattern_ must be set.

However, for cases in which the regular expressions used to constrain string values within the application schema are known to be valid in the regular expression dialects of both JSON Schema and XML Schema, ShapeChange offers a way to define the regular expression only once per application schema element, and still derive XML Schema and JSON Schema from the conceptual model. https://shapechange.net/get-started/config/input/#Tag_aliases[Tag aliases] can be used in the ShapeChange configuration, to map the name of a tagged value to a different name. Tag _pattern_ could thus be mapped to tag _jsonPattern_. However, tag aliases do not create copies of tagged values with different name. Tag aliasing results in renaming tags. Therefore, in order to derive both XML Schema and JSON Schema from an application schema, ShapeChange would have to be executed twice: once without mapping tag _pattern_, to create the XML Schema, and once with mapping tag _pattern_ to tag _jsonPattern_, and then deriving JSON Schema.

======

NOTE: If the "format" keyword is used to restrict the structure of a JSON string, so that it matches a certain regular expression, then it is useful to add the "pattern" keyword as well, explicitly defining that regular expression (given that the regular expression follows an ECMA 262 regular expression dialect). The reason is that the "format" is first and foremost an annotation, so can be ignored by JSON Schema validators, whereas the "pattern" keyword will be evaluated by a JSON Schema validator. JSON Schema validators may treat the "format" keyword like an assertion, but that is not guaranteed. In any case, the "format" keyword helps to convey more information about the specific type of a JSON value (e.g., "date" instead of just "string"), and thus should not be omitted if a certain, well-known (i.e., defined by a JSON Schema vocabulary) format is applicable to a JSON value.

There are a number of cases which need to be considered when encoding a basic type.

* The basic type directly inherits from a type that is mapped to one of the simple JSON Schema types listed above: in that case, the JSON Schema definition of the basic type will include the "type" keyword with appropriate value, and potentially also the "format" keyword if the mapping defines a specific format. In addition, restrictions defined for the basic type via tagged values are encoded using the appropriate JSON Schema keywords (as defined in <<table_basictypes_restrictions>>).
* Otherwise, i.e., the basic type does not directly inherit from a type that is mapped to a simple JSON Schema type:
** If no restrictions are defined for the basic type, then the JSON Schema definition of the basic type simply contains a "$ref" to the JSON Schema definition of the direct supertype.
** Otherwise, i.e., restricitons are defined, an "allOf" is used to refer to the JSON Schema definition of the direct supertype, and to define a JSON Schema with the restrictions that apply to the basic type.

<<img_jsonschema_basictypes_example>> provides a detailed example that illustrates these cases. The JSON Schema encoding is shown in <<example_jsonschema_basictypes>>.

[#img_jsonschema_basictypes_example,reftext='{figure-caption} {counter:figure-num}']
.Basic types example
image::images/basic_types_example.png[align="center"]

[#example_jsonschema_basictypes,reftext='{listing-caption} {counter:listing-num}']
.Example of basic types encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MyBoolean": {
      "type": "boolean"
    },
    "MyCharacterString": {
      "type": "string"
    },
    "MyNumber": {
      "type": "number"
    },
    "Number0to360": {
      "allOf": [
        {
          "$ref": "#/definitions/NumberNonNegative"
        },
        {
          "maximum": 360.0
        }
      ]
    },
    "NumberMinus180toPlus180": {
      "allOf": [
        {
          "$ref": "#/definitions/MyNumber"
        },
        {
          "minimum": -180.0,
          "maximum": 180.0
        }
      ]
    },
    "NumberNonNegative": {
      "allOf": [
        {
          "$ref": "#/definitions/NumberOther"
        },
        {
          "minimum": 0.0
        }
      ]
    },
    "NumberOther": {
      "$ref": "#/definitions/MyNumber"
    },
    "String10": {
      "allOf": [
        {
          "type": "string"
        },
        {
          "maxLength": 10
        }
      ]
    },
    "StringFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/MyCharacterString"
        },
        {
          "format": "email"
        }
      ]
    },
    "StringPattern": {
      "allOf": [
        {
          "$ref": "#/definitions/MyCharacterString"
        },
        {
          "pattern": "^[abc]{3}$"
        }
      ]
    }
  }
}
----

[[jsonschema_schemaconversionrules_types_defaultgeometry]]
===== Default Geometry

// implementation status: implemented

By default, any property with a geometry type is converted as any other property, with the geometry type being mapped to a JSON Schema as defined via map entries (see section <<jsonschema_schemaconversionrules_types_mappings>>).

This may not always be desired. A GeoJSON Feature, for example, has a dedicated (and required) member - "geometry" - for encoding the feature geometry. Geometry properties defined within an application schema may therefore need to be mapped to this "geometry" member. Additional conversion behavior is required to define and achieve this mapping.

Two kinds of application schemas need to be distinguished:

. application schemas where a class has at most one geometry property, typically a property with one of the ISO 19107 geometry types as value type; and
. application schemas where classes can have more than one geometry property.

NOTE: When counting geometry properties per class, inheritance also needs to be considered. A class that, through inheritance, has multiple geometry typed properties with different name belongs to an application schema of the second category, whereas a class that only has at most one geometry typed property - also through inheritance - belongs to the first category.

Two conversion rules are available to support the two kinds of application schemas.

* __rule-json-cls-defaultGeometry-singleGeometryProperty__ - for application schemas with classes that have at most one geometry property. With this rule, the geometry property of a class represents the default geometry, and is encoded as the top-level "geometry" member. If a class has multiple - potentially inherited - geometry properties with different names, none of them is selected as default geometry (because no informed choice can be made) and ShapeChange will log an error.
* __rule-json-cls-defaultGeometry-multipleGeometryProperties__ - for application schemas with classes that can have multiple geometry properties. With this rule, a geometry property is identified as default geometry by setting tagged value _defaultGeometry_ on the property to the value `true`. That property will then be encoded as a top-level "geometry" member. If multiple such properties exist (potentially inherited), none of them is selected as default geometry (because no informed choice can be made) and an error will be logged.
+
NOTE: For a class that has multiple geometry properties with different names, all such properties except the one identified as default geometry are encoded just as any other property of the class. A different behavior would be to omit these other geometry properties altogether when deriving the JSON Schema. It is unclear at this point if that would really be useful behavior. After all, the modeling expert that designed the application schema with classes that have multiple geometry properties must have had good reasons for doing so, and must also be aware that in order to perform spatial computations on the different geometry properties, special software will be required.

If a UML property is identified as default geometry, then it is implemented via the top-level "geometry" member (and not as another member of the JSON object). The "geometry" member is constrained to the JSON Schema definition to which the value type of the default geometry property is mapped.

NOTE: The schema should only use geometry types that are mapped in the configuration of the ShapeChange process. For example, in the case of a GeoJSON encoding rule, all geometry types should be mapped to GeoJSON geometry types. Otherwise the JSON Schema constraints of the GeoJSON Feature schema could not be satisfied.

NOTE: One might think that it is beneficial to set the "geometry" member to just `null` if the type that is being converted does not have a default geometry. However, that must not be done in any schema conversion, because then a default geometry defined by a super- or (maybe defined in an external schema) subtype of that type could never be mapped to the "geometry" member. The only exception would be classes marked as "final," where none of the supertypes define a default geometry.

NOTE: If the default geometry property has a maximum multiplicity greater than 1, then ShapeChange will log a warning and assume a maximum multiplicity of exactly 1.

NOTE: <<example_jsonschema_encrule_geojson>> illustrates the result of applying __rule-json-cls-defaultGeometry-singleGeometryProperty__, given the feature type in <<img_jsonschema_encrule_geojson_uml>>.

NOTE: Additional geometry properties are encoded like all other UML properties (in the GeoJSON case within the GeoJSON "properties" member).

NOTE: In some application schemas, the geometry of a feature type is not defined directly, i.e., not via a property that has an ISO 19107 type as value type. For example, consider REF img_jsonschema_value_type_options_example, where property "place" indirectly defines the geometry of a feature type, through a complex _PlaceSpecification_. The place is either given by a point, a curve, a surface, or by some location identifier. Such a feature model, where the geometry of a feature can be one of several geometry and non-geometry types, is not suited for the conversion rules documented in this section.

[[jsonschema_schemaconversionrules_properties]]
==== Properties

A UML property of a class is converted to a member of a JSON object - unless the encoding rule defines a different behavior for the type that owns the property (e.g., for enumerations and code lists).

The default result of converting a UML property, therefore, is a key within the "properties" key of the JSON Schema definition for the type that owns the property, with the key name being the name of the UML property, and the value being a JSON Schema with constraints and annotations that define the property (value type, multiplicity, etc).

The following figure and listing provide an example: <<img_jsonschema_properties_example>> shows a feature type with a number of properties. <<example_jsonschema_properties_general>> illustrates how the UML properties are represented within the "properties" of the JSON Schema that defines that type.

[#img_jsonschema_properties_example,reftext='{figure-caption} {counter:figure-num}']
.UML type used to exemplify JSON Schema encoding of UML properties
image::images/Properties_example.png[align="center"]

[#example_jsonschema_properties_general,reftext='{listing-caption} {counter:listing-num}']
.Encoding UML properties in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeX": {
      "type": "object",
      "properties": {
        "property1": { ... },
        "property2": { ... },
        ...
      }
    }
  },
  "$ref": "#/definitions/TypeX"
}
----

[[jsonschema_schemaconversionrules_properties_valuetype]]
===== Value Type

// implementation status: implemented - except for specialization case

If a mapping is defined for the value type of a UML property, then the JSON value type or JSON Schema defined by the mapping is used in the JSON Schema that constrains the property:

* If the value type maps to a simple JSON value type, i.e., "string", "number", or "boolean", then a "type" key is added to the JSON Schema, with the JSON value type as value;
* Otherwise, the mapping references a JSON Schema that defines the value type. In that case, a "$ref" key is added to the JSON Schema that constrains the property, with the reference defined by the mapping as value.

If no mapping is available, then:

* Typically the value type is defined by one of the application schemas that are converted, and the value type itself is also converted (encoding of a type or property can be prevented with an additional rule, see <<jsonschema_schemaconversionrules_additionalrules>>). A "$ref" key is added to the JSON Schema that constrains the property. The value of that key references the definition of the type within the definitions schema that is produced for the schema to which the type belongs. The reference uses the identifier of that schema (see <<jsonschema_schemaconversionrules_schemapackage_schemaidentifier>>) as a basis, and adds a fragment identifier to identify the definition of the type. If __rule-json-cls-name-as-anchor__ (see <<jsonschema_schemaconversionrules_types_classname_anchor>>) applies to the type, then the type name is used as fragment identifier. Otherwise, a JSON Pointer will be created. For example:
** using anchor: https://example.org/schemaA/schema_definitions.json#TypeX
** using JSON Pointer:
*** For a draft 07 JSON Schema: https://example.org/schemaA/schema_definitions.json#/definitions/TypeX
*** For a 2019-09 JSON Schema: https://example.org/schemaA/schema_definitions.json#/$defs/TypeX

// However: If the value type has subtypes, and rule-json-cls-specialization as well as rule-cls-name-as-entityType are defined in the encoding rule that applies to the value type, then the reference will point to the value type definition created by rule-json-cls-specialization. For further details, see  section Specialization.

// TBD: This only considers supertypes from within the application schema that is converted; it does not consider supertypes from external schemas that are used - and maybe extended - within the application schema but which are not converted themselves. For such types, the definitions schema may need to define value types itself. For example: using anchor: https://example.org/schemaA/schema_definitions.json#TypeX_valueType using JSON Pointer: https://example.org/schemaA/schema_definitions.json#/definitions/TypeX_valueType

* If the value type is not defined by an application schema that is being converted, or the type itself is not converted at all, then ShapeChange will log an error and omit the type definition for the property altogether.

[[jsonschema_schemaconversionrules_properties_valuetype_valuetypeoptions]]
A specific rule has been added to support value type restrictions for UML properties, which in the NAS are defined using OCL constraints (for further details - and especially an example, see section <<jsonschema_schemaconversionrules_constraint>>): __rule-json-cls-valueTypeOptions__. This rule looks for tagged value __valueTypeOptions__ on a class. If the tag exists and has a value, it defines which types are allowed as value type for a given UML property. Note that this UML property can be directly defined on the class but also be inherited from a supertype. The property can also originally have been an association role that belonged to an association class. The conversion rule ensures that instead of the actual value type of the property, only one of the allowed types is encoded as type definition in the JSON Schema. The conversion also takes into account that the property may have been a role of an association class. The restriction to a set of allowed types uses an if-then-else construct, which depends on the presence of a type identifying member (see section <<jsonschema_schemaconversionrules_types_classname_typeidentification>>) in property values, and thus __rule-json-cls-valueTypeOptions__ should always be used in combination with __rule-json-cls-name-as-entityType__. Note that value type restrictions (defined on a subtype) of inherited UML properties will result in these properties being explicitly defined in the JSON Schema definition of the subtype. The JSON Schema types of the allowed (UML) types are determined as described before. Further details on how the tagged value __valueTypeOptions__ is structured and how it can be derived from OCL constraints are given in section <<jsonschema_transformationrules_valuetyperestrictionocl>>.

[[jsonschema_schemaconversionrules_properties_inlineOrByReference]]
The behavior described so far covers the case of an inline encoding of the property value. In some cases, particularly if the value type is a type with identity, it can be preferable and maybe even necessary to encode the value by reference. In other cases, both options should be offered. That is similar to what the GML Application Schema encoding rules support (for further details, see OGC 07-036r1, Annex E, section E.2.4.11).

[NOTE]
======
An example where a reference to an object is needed is when the object is the value of properties from multiple other objects that are encoded within the same JSON document. For example, a feature referenced from several other features. In such a situation, it is often desirable not to encode the object inline multiple times - especially if that object also referenced other objects.
======

UML properties within an application schema typically have a tagged value _inlineOrByReference_, with one of three values: _inlineOrByReference_, _byReference_, or _inline_.

[NOTE]
======
The default value (for an empty or missing _inlineOrByReference_ tagged value) is defined via the ShapeChange JSON Schema target parameter _inlineOrByReferenceDefault_. The default value of that parameter is _byReference_ . That default value is different to GML. _byReference_ has been chosen as default in order to reduce the degrees of freedom and to reduce the schema complexity.

If association roles within an application schema had tagged value _inlineOrByReference_ all set to _inlineOrByReference_, then setting target parameter _inlineOrByReferenceDefault_ would have no effect. A by reference encoding of association roles can still be achieved with ShapeChange, using a model transformation (e.g., the identity transformation), and https://shapechange.net/transformations/common-transformer-functionality/#Setting_Tagged_Values[setting tagged values during the post-processing phase of that transformation]. More specifically, one would instruct ShapeChange to set tagged value _inlineOrByReference_ for all association roles to _byReference_.

======

When encoding the value type of a UML property in JSON Schema, the _inlineOrByReference_ tagged value is taken into account:

* If the tag value is _inline_, then the behavior described above is applied;
* Otherwise, if the tag value is _byReference_, then by default the "type" key of the property will be defined with value "string" and `"format": "uri"`. +
+
NOTE: The default behavior can be overridden by setting the ShapeChange JSON Schema target parameter _byReferenceJsonSchemaDefinition_. The parameter value is a URI to a JSON Schema definition of a link object, for example as shown in <<example_jsonschema_link_object>>. In actual JSON data, such a link object would be used to encode the reference.
* Otherwise, i.e., the tag value is _inlineOrByReference_, the two options above are combined using the "oneOf" keyword. +
+
NOTE: The result is an XOR type of check, i.e., a value can either be given inline or by reference, but not both. This is different to GML, where in the case of _inlineOrByReference_ and a complex value type a value can be given both inline and by reference.

This is restricted to properties where the value is a type with identity, which is not mapped to a simple JSON Schema type. Otherwise the value is always encoded inline.

NOTE: Some applications may prefer to reference types with identity using a code (of type string or number) instead of using a URI. That code could be seen as a foreign key. In such cases, a model transformation should be applied first, which, for all properties whose value type is a type with identity, replaces the value type with _CharacterString_ or __Number__. The ShapeChange TypeConverter transformer could be enhanced to support such a transformation.

NOTE: Current conversion behavior for value types does not enable by reference encoding for value types that are data types. In general, a data type does not have identity, and therefore a data type value should always be encoded inline, not by reference. The XML Schema encoding rule defined by ISO 19139:2007, typically used to encode metadata schemas (as defined by ISO 19115, and extensions thereof), on the other hand, allows by reference encoding for data type values. When comparing the previous version of ISO 19115 (from 2003/2006) against the current version (from 2014), we can see that some classes that were defined as data types in the previous version are now defined as object types, for example _CI_Citation_. This indicates that the assignment of the \<<dataType>> stereotype has been corrected, in order to reflect in the conceptual model that the type shall be a type with identity.

NOTE: If specialization needed to be supported (for further details, see section <<jsonschema_schemaconversionrules_types_inheritance_specialization>>), then the logic for determining the value type would need to be extended, to cover cases where the value type is a supertype. A particular example of such a situation can be found in the NAS, where an ISO type is used as value type, with the NAS actually defining a subtype of that ISO type.

[[jsonschema_schemaconversionrules_properties_multiplicity]]
===== Multiplicity

// implementation status: implemented

If the minimum cardinality of a UML property is 1 or greater, then the property will be listed under the "required" properties of the object to which the property belongs.

NOTE: Specific conversion rules may override this behavior, for example the rules for converting a \<<union>> (see section <<jsonschema_schemaconversionrules_types_union>>).

In addition, if the maximum cardinality of the property is greater than 1, then a JSON Schema will be created for the property as follows.

* The "type" of the JSON property is set to "array", with the "items" keyword containing the JSON Schema constraints that are created to represent the value type of the property.
* If the minimum cardinality is greater than 0, it is encoded using the "minItems" keyword.
* If the maximum cardinality is not unbounded, it is encoded using the "maxItems" keyword.
* If the values of the property must be unique (which is the default for UML properties), then that is represented by adding `"uniqueItems": true`.

[#img_jsonschema_properties_multiplicity_example,reftext='{figure-caption} {counter:figure-num}']
.UML type used to exemplify JSON Schema encoding of multiplicity
image::images/Multiplicity_example.png[align="center"]

[#example_jsonschema_properties_multiplicity,reftext='{listing-caption} {counter:listing-num}']
.Example for encoding multiplicity in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type": {
      "type": "object",
      "properties": {
        "property": {
          "type": "array",
          "minItems": 1,
          "maxItems": 2,
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "required": [
        "property"
      ]
    }
  },
  "$ref": "#/definitions/Type"
}
----

This JSON object is valid against the schema from <<example_jsonschema_properties_multiplicity>>:

[source,json,linenumbers]
----
{
"property": ["a","b"]
}
----

This JSON object is invalid (because "property" has three values, which exceeds the maximum amount of allowed values) against the schema from <<example_jsonschema_properties_multiplicity>>:

[source,json,linenumbers]
----
{
"property": ["a","b",""]
}
----

NOTE: All arrays in JSON are ordered, thus that the values of a UML property are ordered is always represented, and that the values of such a property are unordered cannot be represented. However, the latter should not matter to an application that does not expect ordered values for a certain property.

NOTE: An alternative approach for encoding a UML property with maximum multiplicity greater than one and a minimum multiplicity of 0 or 1 would be to allow either the type or an array of the type, so that a single value does not need to be encoded as an array. However, it is unclear if JSON tools generally support such an approach, i.e., encoding JSON member values as either a single value or within an array. Therefore, no conversion rule to support the alternative approach has been defined yet.

[[jsonschema_schemaconversionrules_properties_voidable]]
===== Voidable

// implementation status: implemented

With __rule-json-prop-voidable__, the JSON Schema of a UML property with stereotype \<<voidable>>, or with tagged value _nillable_ = true, is defined in a way that only allows either a null value or a(n array of) actual value(s).

* If the UML property has maximum multiplicity 1, then a simple "type" restriction with value "null" is added to the type definition that is produced for the property.
* Otherwise - the maximum multiplicity is greater than 1 - a choice (encoded using the "oneOf" keyword) between a "null" value and an array of actual values will be created.

[#img_jsonschema_properties_voidable_example,reftext='{figure-caption} {counter:figure-num}']
.Example for JSON Schema encoding of a voidable property with max multiplicity 1
image::images/Voidable_example.png[align="center"]

[#example_jsonschema_properties_voidable_maxmult1,reftext='{listing-caption} {counter:listing-num}']
.Encoding a voidable UML property with max multiplicity 1 in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type1": {
      "type": "object",
      "properties": {
        "propertyA": {
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/Type2"
            }
          ]
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "Type2": {
      "type": "object",
      "properties": {
        "propertyB": {
          "type": "string"
        }
      },
      "required": [
        "propertyB"
      ]
    }
  },
  "$ref": "#/definitions/Type1"
}
----

The following two JSON objects are valid against the schema from <<example_jsonschema_properties_voidable_maxmult1>>:

[source,json,linenumbers]
----
{
  "propertyA": null
}
----

[source,json,linenumbers]
----
{
  "propertyA": {
    "propertyB": "x"
  }
}
----

This JSON object is invalid (because "propertyB" is not allowed to be null) against the schema from <<example_jsonschema_properties_voidable_maxmult1>>:

[source,json,linenumbers]
----
{
  "propertyA": {
    "propertyB": null
  }
}
----

If propertyA from the example shown in <<img_jsonschema_properties_voidable_example>> had maximum multiplicity of "*", then the resulting JSON Schema would be as in <<example_jsonschema_properties_voidable_maxmultgreater1>>

[#example_jsonschema_properties_voidable_maxmultgreater1,reftext='{listing-caption} {counter:listing-num}']
.Encoding a voidable UML property with max multiplicity greater than 1 in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type1": {
      "type": "object",
      "properties": {
        "propertyA": {
          "oneOf": [
            {
              "type": "null"
            },
            {
              "type": "array",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/Type2"
              },
              "uniqueItems": true
            }
          ]
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "Type2": {
      "type": "object",
      "properties": {
        "propertyB": {
          "type": "string"
        }
      },
      "required": [
        "propertyB"
      ]
    }
  },
  "$ref": "#/definitions/Type1"
}
----

To encode the nil/null reason a separate, parallel property "xyz_nilReason" (or similar) could be added. This is implemented using a <<jsonschema_transformationrules_nilreason_property,new transformation>>, not as part of the JSON Schema encoding rule.


[[jsonschema_schemaconversionrules_properties_readonly]]
===== Fixed / readOnly

// implementation status: implemented

With __rule-json-prop-readOnly__, the JSON Schema definition of a UML property that is read only or fixed will include the "readOnly" annotation with JSON value true.

NOTE: With __rule-json-prop-derivedAsReadOnly__, a UML property marked as derived will also be encoded with `"readOnly": true`.


[[jsonschema_schemaconversionrules_properties_initialvalue]]
===== Initial Value

// implementation status: implemented

With __rule-json-prop-initialValueAsDefault__, the JSON Schema definition of a UML attribute that has an initial value, is not owned by an enumeration or code list, and whose value type is mapped to "string", "number", or "boolean", will include the "default" annotation with that value.

NOTE: The value of the annotation can have any JSON value type. The initial value is encoded accordingly: quoted, if the property type is "string", unquoted if the property type is "number", and true if the property type is "boolean" and the initial value is equal to, ignoring case, "true"; otherwise the value will be false. Theoretically, the default value can also be a JSON array or object, but that cannot be represented in UML and thus is not a relevant use case.

[[jsonschema_schemaconversionrules_associationclass]]
==== Association Class

There is no native represention for association classes in JSON or JSON Schema. For schemas that include association classes, a transformation of association classes as defined by GML 3.3 and implemented by the https://shapechange.net/transformations/association-class-mapper/[ShapeChange Association Class Mapper] should be used.

[[jsonschema_schemaconversionrules_constraint]]
==== Constraints

OCL constraints can be used to enrich a conceptual model with requirements that cannot be expressed in UML alone. A full analysis of options for converting OCL expressions to something with which JSON data can be checked is out-of-scope for UGAS-2020.

// , and therefore <<overview_future_work_jsonschema_ocl,future work>>.

However, a particular type of OCL constraint defined in the NAS has been identified as critical for achieving a useful JSON Schema encoding of the NAS in UGAS-2020: constraints that disallow related entity types. 

// <<img_jsonschema_value_type_options_example>> provides an example.

// [#img_jsonschema_value_type_options_example,reftext='{figure-caption} {counter:figure-num}']
// .Example where OCL constraints restrict the set of allowed value types for property "place"
// image::images/value_type_options_example.png[align="center"]

The value type of property _place_ is the abstract type _PlaceSpecification_. That type is the root of an inheritance hierarchy, which contains four non-abstract classes. With typical UML semantics, the value of _place_ can thus be any non-abstract subtype of _PlaceSpecification_. In the given example, that would be one of the types _PointPositionSpecification_, _CurvePositionSpecification_, _SurfacePositionSpecification_, and _LocationSpecification_. Note that further characteristics of these types, e.g., UML properties, have been omitted for brevity.

Diagram notes attached to the feature types _FT1_ and _FT2_ indicate that only a subset of non-abstract _PlaceSpecification_ subtypes are actually allowed as value of property _place_. The according OCL constraints are defined as follows:

* FT1 - OCL constraint "Place Representations Disallowed": `inv: place->forAll(p| not(p.oclIsKindOf(CurvePositionSpecification) or p.oclIsKindOf(SurfacePositionSpecification)))`
* FT2 - OCL constraint "Place Representations Disallowed": `inv: place->forAll(p| not(p.oclIsKindOf(CurvePositionSpecification) or p.oclIsKindOf(SurfacePositionSpecification)  or p.oclIsKindOf(LocationSpecification)))`

NOTE: Because the OCL constraint of FT2 has the same name as that of FT1, it overwrites the constraint that would be inherited from FT1.

In order to realize the value type restriction defined by such an OCL constraint, a model transformation - described in section <<jsonschema_transformationrules_valuetyperestrictionocl>> has been added to ShapeChange. In short, the transformation determines which value types are allowed for a UML property of a class (given that a value type restriction is defined for that property), and adds information about the allowed types to the model using a tagged value. That tagged value is used by __rule-json-cls-valueTypeOptions__ (see section <<jsonschema_schemaconversionrules_properties_valuetype>>) to encode the value type restriction in JSON Schema.

NOTE: The model transformation also determines if the property is an association role whose association actually is an association class. If so, that information is added to the tagged value. As described in section <<jsonschema_schemaconversionrules_associationclass>>, JSON Schema cannot directly represent association classes, and therefore such model constructs need to be transformed as defined by the GML 3.3 encoding rules. The resulting model structure is taken into account by __rule-json-cls-valueTypeOptions__, as shown in the following example.

<<example_jsonschema_valuetypeoptions_example>> shows how the value type restrictions for property _place_ in the example used in this section are encoded in JSON Schema, assuming an inline encoding of _place_ to achieve a more simple JSON Schema example.

[#example_jsonschema_valuetypeoptions_example,reftext='{listing-caption} {counter:listing-num}']
.Encoding a value type restriction in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "$defs": {
    "CurvePositionSpecification": { ... },
    "FeaturePlaceRelationship": {
      "$anchor": "FeaturePlaceRelationship",
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        },
        "place": {
          "$ref": "#/$defs/PlaceSpecification"
        }
      },
      "required": [
        "@type",
        "place"
      ]
    },
    "LocationSpecification": { ... },
    "PlaceSpecification": { ... },
    "PointPositionSpecification": { ... },
    "PositionSpecification": { ... },
    "SurfacePositionSpecification": { ... },
    "FT1": {
      "$anchor": "FT1",
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        },
        "place": {
          "oneOf": [
            {
              "type": "null"
            },
            {
              "allOf": [
                {
                  "$ref": "#/$defs/FeaturePlaceRelationship"
                },
                {
                  "type": "object",
                  "properties": {
                    "place": {
                      "if": {
                        "properties": {
                          "@type": {
                            "const": "LocationSpecification"
                          }
                        }
                      },
                      "then": {
                        "$ref": "#/$defs/LocationSpecification"
                      },
                      "else": {
                        "if": {
                          "properties": {
                            "@type": {
                              "const": "PointPositionSpecification"
                            }
                          }
                        },
                        "then": {
                          "$ref": "#/$defs/PointPositionSpecification"
                        },
                        "else": false
                      }
                    }
                  }
                }
              ]
            }
          ]
        }
      },
      "required": [
        "@type",
        "place"
      ]
    },
    "FT2": {
      "$anchor": "FT2",
      "allOf": [
        {
          "$ref": "#/$defs/FT1"
        },
        {
          "type": "object",
          "properties": {
            "place": {
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "allOf": [
                    {
                      "$ref": "#/$defs/FeaturePlaceRelationship"
                    },
                    {
                      "type": "object",
                      "properties": {
                        "place": {
                          "if": {
                            "properties": {
                              "@type": {
                                "const": "PointPositionSpecification"
                              }
                            }
                          },
                          "then": {
                            "$ref": "#/$defs/PointPositionSpecification"
                          },
                          "else": false
                        }
                      }
                    }
                  ]
                }
              ]
            }
          }
        }
      ]
    }
  },
  "$ref": "#/$defs/FT2"
}
----

The following JSON object is valid against the schema for FT2.

[source,json,linenumbers]
----
{
  "@type": "FT2",
  "place": {
  	"@type" : "FeaturePlaceRelationship",
      "place": {
        "@type": "PointPositionSpecification"
      }
  }
}
----

The next JSON object is invalid against the schema for FT2, because the @type of the _PlaceSpecification_ object that is the value of the _FeaturePlaceRelationship.place_ property is _LocationSpecification_ - which is allowed for FT1, but not for FT2.

[source,json,linenumbers]
----
{
  "@type": "FT2",
  "place": {
  	"@type" : "FeaturePlaceRelationship",
      "place": {
        "@type": "LocationSpecification"
      }
  }
}
----

NOTE: That _place_ is a mandatory property results in "place" being added to the "required" member of the JSON Schema for FT1. There is no need to repeat this requirement in the encoding of FT2. However, other definitions would need to be repeated to achieve a consistent JSON Schema, such as that the value of the property is an array (if maximum multiplicity of the property is greater than 1), and that a null value is allowed (if the property is voidable).

[[jsonschema_schemaconversionrules_additionalrules]]
==== Additional rules

If __rule-json-all-notEncoded__ applies to an element of the application schema, then that element and all its components are not encoded.

NOTE: How to define the encoding rule that applies to an application schema element is documented in more detail <<applying_specific_encoding_rule_to_model_element,here>>. The http://shapechange.net/resources/config/StandardRules.xml[ShapeChange configuration file StandardRules.xml] defines an encoding rule named "notEncoded", which includes __rule-json-all-notEncoded__. When StandardRules.xml is included in the configuration of the JSON Schema target (typically using an xinclude XML element), then by setting tagged value _jsonEncodingRule_ to "notEncoded", one would achieve that that model element is not encoded in the JSON Schema.

[[jsonschema_instanceconversionrules]]
=== Instance Conversion Rules

This section documents recommendations and relevant aspects for encoding geospatial data in JSON.

[[jsonschema_instanceconversionrules_geojson_crs]]
==== Coordinate Reference System in JSON data

The <<ref_geojson,GeoJSON standard>> requires that all GeoJSON coordinates use __urn:ogc:def:crs:OGC::CRS84__ as coordinate reference system (CRS), with optional height in meters above or below the WGS 84 reference ellipsoid. Alternative CRSs are not allowed by this standard.

The <<ref_ogcapi_features_part1,OGC API - Features - Part 1: Core>> standard essentially has the same requirement:

[quote,OGC API - Features - Part 1: Core; section 7.11]
____
Unless the client explicitly requests a different coordinate reference system, all spatial geometries SHALL be in the coordinate reference system http://www.opengis.net/def/crs/OGC/1.3/CRS84 (WGS 84 longitude/latitude) for geometries without height information and http://www.opengis.net/def/crs/OGC/0/CRS84h (WGS 84 longitude/latitude plus ellipsoidal height) for geometries with height information.
____

A previous version of the GeoJSON standard did allow alternative CRSs, but that option has been removed _"because the use of different coordinate reference systems has proven to have interoperability issues"_ (<<ref_geojson,GeoJSON standard>>, chapter 4). However, the GeoJSON standard also states that if all involved parties have a prior arrangement, then alternative CRSs can be used.

The <<ref_ogcapi_features_part1,OGC API - Features - Part 1: Core>> standard also does not preclude the use of additional CRSs, but does not specify how to request features in such reference systems. That is the purpose of _OGC API - Features - Part 2: Coordinate Reference Systems by Reference_, which is currently under development.

To summarize: Coordinates of GeoJSON compliant data as well as spatial data accessed using the _OGC API - Features_ standard must be given in OGC CRS84 (with optional height). That has implications for data publishers and consumers. A major benefit is increased interoperability, because spatial datasets that use the same CRS can easily be merged. If a use case requires other CRSs, then both GeoJSON and the OGC API - Features standards have options to support that. Data publisher and consumer only need to agree on the CRS in which the coordinates of spatial data, that is being exchanged between the two, is given in.

// Has the profile chapter more to say on CRS in JSON?

[[jsonschema_transformationrules]]
=== Conceptual Model Transformation Rules

The conceptual schema may need to be transformed, in order to deal with model elements:

* that cannot be represented in JSON at all (e.g., association classes);
* that cannot be represented in a certain JSON format (e.g., a Solid - a 3D geometry type - as value for the "geometry" member of a GeoJSON feature); or
* that are not (well) supported by client software (e.g., complex attribute values for styling, processing, and filtering).

The following sections describe model transformations that can be useful to deal with these restrictions when encoding application schemas as JSON Schemas.

[[jsonschema_transformationrules_inheritance]]
==== Flattening Inheritance

As mentioned in section <<jsonschema_schemaconversionrules_types_inheritance>>, JSON Schema does not directly support the concept of inheritance. There are ways to represent inheritance in JSON Schema to a certain extent. Generalization can be represented using an "allOf" that includes the schema of a subtype and the schema(s) of its supertype(s). Specialization can be represented as a relatively complex if-then-else construct, with which JSON objects - that encode types from a type hierarchy) can be validated based upon a property value that declares their type.

If a community does not want to apply these solutions for representing inheritance in JSON Schema, but still wants to use inheritance in their concpetual model and derive a JSON Schema encoding from it, then inheritance needs to be transformed on the conceptual level. Generalization (in the sense of <<jsonschema_schemaconversionrules_types_inheritance_generalization>>) would be transformed by copying all properties of a supertype down to direct and indirect subtypes. For each supertype, a union of the non-abstract types in the hierarchy of that supertype (including the supertype itself) would be created, and the value type of each property that is that supertype would be switched to the union. That would allow the encoding of subtypes, instead of the supertype, as property value - and thus support specialization (in the sense of <<jsonschema_schemaconversionrules_types_inheritance_specialization>>).

The transformation of inheritance is implemented by the ShapeChange __Flattener__ transformer, in __rule-trf-cls-flatten-inheritance__. The https://shapechange.net/transformations/flattener/#rule-trf-cls-flatten-inheritance[documentation of the rule] provides further details.

NOTE: The introduction of new unions as value types, for properties that have a supertype as value type, creates a level of indirection that may not be desirable. One approach to avoid the indirection would be to flatten the unions using another transformation, i.e., <<jsonschema_transformationrules_complextypes>> (though that would create additional properties and remove the union semantics). Another approach would be to encode these unions as object references. This approach has been used in the creation of a GML-SF Level 0 XML Schema in OGC Testbed 13 (for further details, see the http://docs.opengeospatial.org/per/17-020r1.html#GMLSF0_XSD[OGC Testbed-13: NAS Profiling Engineering Report, section 7.2.19. XML Schema encoding, rule-xsd-cls-union-omitUnionsRepresentingFeatureTypeSets].

[[jsonschema_transformationrules_multiplicity]]
==== Flattening Multiplicity

Simple JSON formats may not support properties with a maximum multiplicity greater than 1. If the conceptual model contains such properties, they can be transformed to a set of properties, each with maximum multiplicity = 1.

This kind of model transformation is implemented in ShapeChange by https://shapechange.net/transformations/flattener/#rule-trf-prop-flatten-multiplicity[rule-trf-prop-flatten-multiplicity] of the __Flattener__ transformer.



[[jsonschema_transformationrules_complextypes]]
==== Flattening Complex Types

A community may want to keep their JSON formats simple by not allowing nested objects within a JSON object, or only a bare minimum (e.g., when their JSON shall be GeoJSON compliant). In such a case, nested objects that represent data types and unions from the conceptual model must be avoided. At the same time, the JSON formats used by the community must still be able to represent the information items that would usually be encoded via these complex types.

https://shapechange.net/transformations/flattener/#rule-trf-prop-flatten-types[rule-trf-prop-flatten-types], implemented by the ShapeChange __Flattener__ transformer, "flattens" these complex types by copying their properties to the types that use the complex types. The names of the property copies are modified to reflect which information items they represent.

[[jsonschema_transformationrules_associationclasses]]
==== Mapping Association Classes

JSON Schema cannot directly represent association classes. An association class therefore needs to be transformed into a structure that can be represented with JSON Schema. The transformation of association classes defined by GML 3.3 is a suitable solution.

The ShapeChange https://shapechange.net/transformations/association-class-mapper/[Association Class Mapper] implements the transformation defined by GML 3.3.

[[jsonschema_transformationrules_propertymetadata]]
==== Transforming Stereotype \<<propertyMetadata>>

In the UGAS-2019 OGC Pilot, the \<<propertyMetadata>> stereotype was developed. When assigned to a property, it indicates that the property can be associated with metadata. The metadata would provide additional information on the property value or values. Tagged value __metadataType__ is defined for the stereotype, and used to identify the actual type that the property references as metadata.

The https://shapechange.net/wp-content/uploads/2019/12/UGAS19-D100_property_stereotypes.pdf[Property Stereotype for Metadata] document describes how the stereotype is encoded in XML Schema. Basically, a "metadata" XML attribute is added on the XML element that represent the property. The XML attribute can be used to reference the metadata object, much like an "xlink:href" XML attribute would be used to reference a "normal" object.

Some encodings - like JSON - do not have anything similar to XML attributes. Section 2.3.2 of the https://shapechange.net/wp-content/uploads/2019/12/UGAS19-D100_property_stereotypes.pdf[Property Stereotype for Metadata] document describes how the \<<propertyMetadata>> stereotype can be handled in such an encoding. In essence, the stereotype is transformed to an additional property, with the type identified by tagged value __metadataType__ as value type.

The transformation is implemented by the ShapeChange __Type Converter__ transformer in __rule-trf-propertyMetadata-stereotype-to-metadata-property__.

* Rule behavior: Converts the \<<propertyMetadata>> stereotype to an additional property, as follows: First, the metadata type that applies to the property with the stereotype is identified: The tagged value __metadataType__ of the property is checked first. If the tagged value does not identify a metadata type, then the type defined by configuration parameter __defaultMetadataType__ is used.
+
[NOTE]
======
The identification of the metadata type by tagged value or by configuration parameter is as follows:

* definition by tagged value _metadataType_: If the type is defined by the schema that contains the property, then the tagged value simply provides the name of the type. Otherwise, the tagged value shall identify the type by its full package-qualified name, starting with the application schema package. For example: "Some Application Schema::Some Subpackage::Another Subpackage::MetadataType."
* definition by configuration parameter _defaultMetadataType_: If the name of the type is unique within the conceptual model, then simply providing the type name as parameter value is sufficient. Otherwise (or as a general alternative), the metadata type is identified by providing its full name (omitting packages that are outside of the schema the class belongs to - see the example above).
======
+
If the configuration parameter also does not identify a type within the conceptual model, an error message will be logged and the stereotype will simply be removed from the property. Otherwise, if the metadata type is a type with identity (feature or object type) then a directed association to the metadata type is created - else an attribute (with the metadatatype as value type) is created. The name of the new association role or attribute is the property name plus suffix defined by configuration parameter __metadataPropertyNameSuffix__. If a new association role was created, tagged value __inlineOrByReference__ of the association role is set to the value defined by configuration parameter __metadataPropertyInlineOrByReference__. Otherwise, i.e., an attribute was created, tagged value __inlineOrByReference__ is set to "inline." Tagged value _sequenceNumber_ will be set in such a way that the new property is placed directly after the original property.
* Configuration parameter __defaultMetadataType__: Name of the type from the conceptual model, which shall be used as metadata type for all properties with stereotype \<<propertyMetadata>> that do not define a metadata type via tagged value __metadataType__. The value can be the pure type name, if it is unique within the conceptual model. Otherwise, the correct type is identified by providing its full name (omitting packages that are outside of the schema the class belongs to). The default value for this parameter is 'MD_Metadata' (which typically refers to the type defined by ISO 19115).
* Configuration parameter __metadataPropertyNameSuffix__: Defines the suffix that shall be added to the name of a new property created by __rule-trf-propertyMetadata-stereotype-to-metadata-property__. Default is'_metadata'.
* Configuration prameter __metadataPropertyInlineOrByReference__: Defines the value for tag __inlineOrByReference__ of a new association role created by __rule-trf-propertyMetadata-stereotype-to-metadata-property__. Default is 'inlineOrByReference'. Other allowed values are 'byReference' and 'inline'.



[[jsonschema_transformationrules_nilreason_property]]
==== Generating NilReason Properties for Nillable Properties

// implementation status: implemented

A UML property that is defined for a feature, object, data, or union type within an application schema, by default cannot have a null value. In order to model that a property can have a null value (instead of actual value(s)), stereotype \<<voidable>> must be added to the property, or tagged value _nillable_ with value 'true'. Such a property is called a _nillable_ property.

The recommendation from the UGAS-2019 OGC Pilot for NAS modelling of nillable properties (for further details, see the https://shapechange.net/wp-content/uploads/2019/12/UGAS19-D100_property_stereotypes.pdf[Property Stereotype for Metadata] document, section 2.2) is to use the \<<voidable>> stereotype, and to also set tagged value _voidReasonType_ on the property, in order to define the enumeration that defines the reasons for a null value.

In the XML Schema encoding, nillable properties are represented by XML elements for which the XML attribute "nilReason" can be set. As also mentioned in section <<jsonschema_transformationrules_propertymetadata>>, some encodings - like JSON - do not have anything similar to XML attributes. In order to encode the reason why a nillable property has a null value in such an encoding, the application schema can be transformed, adding a new property for each nillable property (to the class that owns the nillable property), with the new property having the void reason type as value type.

The according transformation is implemented by the ShapeChange __Type Converter__ transformer in __rule-trf-nilReason-property-for-nillable-property__.

* Rule behavior: For each property that is nillable (has stereotype \<<voidable>> or tagged value _nillable_ set to 'true'), create a new attribute, as follows: First, the void reason type that applies to the nillable property is identified: The tagged value _voidReasonType_ of the nillable property is checked first. If the tagged value does not exist or does not identify a type, then the type defined by configuration parameter _defaultVoidReasonType_ is used.
+
[NOTE]
======
The identification of the void reason type by tagged value or by configuration parameter is as follows.

* Definition by tagged value _voidReasonType_: If the type is defined by the schema that contains the property, then the tagged value simply provides the name of the type. Otherwise, the tagged value shall identify the type by its full package-qualified name, starting with the application schema package. For example: "Some Application Schema::Some Subpackage::Another Subpackage::VoidReasonType".
* Definition by configuration parameter _defaultVoidReasonType_: If the name of the type is unique within the conceptual model, then simply providing the type name as parameter value is sufficient. Otherwise (or as a general alternative), the void reason type is identified by providing its full name (omitting packages that are outside of the schema the class belongs to - see the example above).
======
+
If the configuration parameter also is not set or does not identify a type within the conceptual model, an error message will be logged and the value type of the new attribute will be CharacterString. Otherwise, the identified type will be set as value type of the new attribute. The name of the new attribute is the name of the nillable property plus suffix defined by configuration parameter _nilReasonPropertyNameSuffix_. Tagged value _inlineOrByReference_ of the new attribute is set to inline. Tagged value _sequenceNumber_ will be set in such a way that it is placed directly after the nillable property.
* Configuration parameter __defaultVoidReasonType__: Name of the type from the conceptual model, which shall be used as void reason type for all nillable properties that do not define a void reason type via tagged value _voidReasonType_. The value can be the pure type name, if it is unique within the conceptual model. Otherwise, identify the correct type by providing its full name (omitting packages that are outside of the schema the class belongs to). No default value is defined for this parameter.
* Configuration parameter __nilReasonPropertyNameSuffix__: Defines the suffix that shall be added to the name of a new property created by __rule-trf-nilReason-property-for-nillable-property__. Default is'_nilReason'.

[[jsonschema_transformationrules_valuetyperestrictionocl]]
==== Transforming OCL Constraints Defining Value Type Restrictions

// implementation status: implemented

An OCL constraint such as `inv: place->forAll(p|not(p.oclIsKindOf(CurvePositionSpecification) or p.oclIsKindOf(SurfacePositionSpecification)))`, and - for the sake of the example used in this section - name "Value Type Representations Disallowed", restricts the set of allowed value types for a property. In the example, property _place_ must not have a value of type _CurvePositionSpecification_ or _SurfacePositionSpecification_. The example is described in more detail in section <<jsonschema_schemaconversionrules_constraint>>.

With __rule-trf-cls-constraints-valueTypeRestrictionToTV-exclusion__ - defined for the https://shapechange.net/transformations/constraintconverter/[ShapeChange _ConstraintConverter_ transformation], the value type restrictions defined by OCL constraints can be extracted from the OCL expression, and converted into a tagged value, to be used by subsequent transformation and conversion processes.

Configuration parameter __valueTypeRepresentationConstraintRegex__ is used to identify the relevant OCL constraints. The parameter value contains a regular expression - for example `.\*Value Type Representations Disallowed.*`, which matches the names of OCL constraints that define value type restrictions. The according OCL expressions must thereby be structured as in the example (with _oclIsTypeOf(..)_ also being supported).

The name of the property that is restricted is parsed from the begin of the OCL expression: `inv: _{propertyName}_\->forAll`... The property name may thereby be preceded by `self.`, i.e., `inv: self._{propertyName}_\->forAll`... is a valid alternative way to structure the value type restricting OCL expression.

Required configuration parameter __valueTypeRepresentationTypes__ specifies the types that are used as value type by the UML properties identified in the value type restricting OCL constraints. For each such type, a list of names of the generally allowed types within the inheritance hierarchy of that type must be provided, which may include the type itself and abstract types. For example, for the value type _PlaceSpecification_ of property _place_ shown in REF img_jsonschema_value_type_options_example, the value of the configuration parameter could be: `PlaceSpecification{PointPositionSpecification, CurvePositionSpecification, SurfacePositionSpecification, LocationSpecification}`. The transformation will automatically add all subtypes of generally allowed types to the set of generally allowed types. That is important for creating a tagged value that explicitly lists the types that are allowed for a property, regardless of inheritance structures, because the OCL constraint may exclude a specific subtype of a generally allowed supertype.

NOTE: If multiple value types need to be described by configuration parameter __valueTypeRepresentationTypes__, then a semicolon is used to separate the descriptions in the parameter value.

The transformation will parse a value type restricting OCL constraint in order to determine the (potentially inherited) UML property to which the constraint applies. The OCL expression is structured so that any type mentioned in the expression is disallowed/excluded. The transformation can therefore determine the value types that are disallowed - also taking into account all subtypes of a type that is mentioned within an _oclIsKindOf(..)_. The set of disallowed types will then be subtracted from the set of generally allowed types, resulting in the set of types that are allowed as value types of the property.

The allowed types for the property are documented in the model by adding (also: overwriting, if it already exists) tagged value _valueTypeOptions_ to the class on which the UML property is defined. The tagged value is structured as follows:

`{propertyName}(\(associationClassRole\))?={allowedTypeName}(,{allowedTypeName})*(;{propertyName}(\(associationClassRole\))?={allowedTypeName}(,{allowedTypeName})*)*`

For the example OCL constraint, that would result in: `place(associationClassRole)=PointPositionSpecification,LocationSpecification`.

NOTE: The example shows that the tagged value may contain a qualifier - _associationClassRole_ - for a property, which, if set, indicates that the property is an association role whose association actually is an association class. That information can be relevant for subsequent processes, for example the JSON Schema encoding, when a previous model transformation has transformed association classes as defined by the GML 3.3 encoding rules.

NOTE: Configuration parameter __valueTypeRepresentationTypes__ can also define an alias for the name of an allowed type. For example: `PlaceSpecification{PointPositionSpecification=P, CurvePositionSpecification=C, SurfacePositionSpecification=S, LocationSpecification=L}`. The alias is used when constructing tagged value _valueTypeOptions_. That can be useful in case that the names of UML types contained in the model are flattened, i.e., replaced by a short name or code, by a subsequent model transformation. Processes that convert such a flattened model and use the information from tagged value _valueTypeOptions_ then have the correct names of allowed value types.

[[jsonschema_encodingrules]]
=== Encoding Rules

This section documents two JSON Schema encoding rules, one for achieving a GeoJSON compliant JSON Schema encoding, and one for producing plain JSON Schemas (typically for non-geospatial schemas).

NOTE: Each of these two rules is implemented in ShapeChange, the first with name "defaultGeoJson", and the second with name "defaultPlainJson". Additional conversion rules can easily be added to such an encoding rule by defining a new encoding rule in the ShapeChange JSON Schema target that extends "defaultGeoJson" or "defaultPlainJson", and setting the new rule as the default encoding rule (using the ShapeChange JSON Schema target parameter _defaultEncodingRule_). If, on the other hand, conversion rules from "defaultGeoJson" or "defaultPlainJson" need to be removed or replaced, for any reason, then these encoding rules cannot be used (ShapeChange supports extending a named encoding rule, but not restricting it), and instead a new encoding rule must be defined that is patterned after the applicable existing rule.

[[applying_specific_encoding_rule_to_model_element]]
NOTE: For some application schemas, it is useful to know that different encoding rules can be applied to the subpackages, classes, and properties defined by the schema. Typically, a single encoding rule applies to all application schema elements. In ShapeChange, that rule is identified by setting the JSON Schema target parameter _defaultEncodingRule_, with the unique name defined for the encoding rule in the target configuration. The target configuration, however, can contain multiple encoding rules (with different names). By setting tagged value _jsonEncodingRule_ on an application schema element, using the name of another encoding rule, the model element will be encoded as defined by that rule. For example, if an application schema used unions in both ways described in section <<jsonschema_schemaconversionrules_types_union>>, then the default encoding rule could include __rule-json-cls-union-propertyCount__, and encoding rule "TypeDiscriminatorUnionRule" could instead include __rule-json-cls-union-typeDiscriminator__. By setting tagged value _jsonEncodingRule=TypeDiscriminatorUnionRule_ on each type discriminator union, these unions would be encoded using __rule-json-cls-union-typeDiscriminator__ and all other unions would be encoded using __rule-json-cls-union-propertyCount__.

[[jsonschema_encodingrules_geojson]]
==== GeoJSON Schema Encoding Rule

In order to achieve a GeoJSON compliant encoding using ShapeChange, set "defaultGeoJson" as the default encoding rule for the JSON Schema target (using the target parameter _defaultEncodingRule_).

This encoding rule consists of the following conversion rules:

* rule-json-cls-defaultGeometry-singleGeometryProperty
* rule-json-cls-ignoreIdentifier
* rule-json-cls-name-as-anchor
* rule-json-cls-nestedProperties
* rule-json-cls-virtualGeneralization
* rule-json-prop-derivedAsReadOnly
* rule-json-prop-initialValueAsDefault
* rule-json-prop-readOnly
* rule-json-prop-voidable

Furthermore, the following parameters need to be added to the configuration of the ShapeChange JSON Schema target:

* baseJsonSchemaDefinitionForFeatureTypes = https://geojson.org/schema/Feature.json
* baseJsonSchemaDefinitionForObjectTypes = https://geojson.org/schema/Feature.json

Geometry types used in the conceptual model (e.g., types from ISO 19107) must be mapped to one of the GeoJSON geometry types (see <<table_jsonschema_encodingrules_geojson_geometrymappings>>).

[#table_jsonschema_encodingrules_geojson_geometrymappings,reftext='{table-caption} {counter:table-num}']
.Mapping ISO 19107 types to GeoJSON geometry types
[cols="1,3a",options="header"]
|====================
| Conceptual geometry type | GeoJSON geometry type
| GM_Point | https://geojson.org/schema/Point.json
| GM_Curve | https://geojson.org/schema/LineString.json
| GM_Surface | https://geojson.org/schema/Polygon.json
| GM_MultiPoint | https://geojson.org/schema/MultiPoint.json
| GM_MultiCurve | https://geojson.org/schema/MultiLineString.json
| GM_MultiSurface | https://geojson.org/schema/MultiPolygon.json
| GM_Object | https://geojson.org/schema/Geometry.json
|====================

NOTE: In order to achieve an OGC JSON encoding, the ShapeChange JSON Schema target parameters _baseJsonSchemaDefinitionForFeatureTypes_ and _baseJsonSchemaDefinitionForObjectTypes_ would have to be set to reference the schema for AnyFeature, shown in #TBD# REF jsonschema_feature. Furthermore, the geometry types would need to be mapped as defined in REF table_profiles_core_spatialtypes_jsimpl.

The feature type illustrated in <<img_jsonschema_encrule_geojson_uml>> is used as example for a GeoJSON based encoding, which is shown in <<example_jsonschema_encrule_geojson>>.

[#img_jsonschema_encrule_geojson_uml,reftext='{figure-caption} {counter:figure-num}']
.Example of a feature type in UML, which will be converted to a GeoJSON feature
image::images/GeoJSON_example.png[align="center"]

[#example_jsonschema_encrule_geojson,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a feature type that is converted using the default GeoJSON encoding rule
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeG": {
      "$id": "#TypeG",
      "allOf": [
        {
          "$ref": "https://geojson.org/schema/Feature.json"
        },
        {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "properties": {
                "propertyG": {
                  "type": "number"
                }
              },
              "required": [
                "propertyG"
              ]
            },
            "geometry": {
              "$ref": "http://geojson.org/schema/Point.json"
            }
          },
          "required": [
            "properties"
          ]
        }
      ]
    }
  },
  "$ref": "#/definitions/TypeG"
}
----

This JSON object is valid against the schema from <<example_jsonschema_encrule_geojson>>:

[source,json,linenumbers]
----
{
  "id": "42445fdasd7asd6f7",
  "type": "Feature",
  "geometry": {
    "type": "Point",
    "coordinates": [8.195669, 51.903589]
  },
  "properties": {
    "propertyG": 3
  }
}
----

This JSON object is invalid against the schema from <<example_jsonschema_encrule_geojson>> (because the JSON value of "geometry" is not valid according to the JSON Schema of a GeoJSON point):

[source,json,linenumbers]
----
{
  "id": "42445fdasd7asd6f7",
  "type": "Feature",
  "geometry": {
    "type": "LineString",
    "coordinates": [
      [102.0,0.0],
      [103.0,1.0],
      [104.0,0.0],
      [105.0,1.0]
    ]
  },
  "properties": {
    "propertyG": 3
  }
}
----

[[jsonschema_encodingrules_plainjson]]
==== Plain JSON Schema Encoding Rule

Some communities have schemas where "geospatial" plays a minor or no role at all. For such cases, the use of GeoJSON features is not relevant. The property nesting and the restrictions of the "type" and "geometry" members defined by the GeoJSON schema could even be a hindrance.

In order to achieve a plain JSON Schema encoding using ShapeChange, set "defaultPlainJson" as the default encoding rule for the JSON Schema target (using the target parameter _defaultEncodingRule_).

This encoding rule consists of the following conversion rules:

* rule-json-cls-name-as-anchor
* rule-json-prop-derivedAsReadOnly
* rule-json-prop-initialValueAsDefault
* rule-json-prop-readOnly
* rule-json-prop-voidable

The geometry types used in the conceptual model should be mapped to the JSON Schema implementations defined by the REF table_profiles_core_spatialtypes_jsimpl,Features Core Profile.

A plain JSON Schema encoding of the feature type that was used as example for the GeoJSON based encoding in the previous section (see <<img_jsonschema_encrule_geojson_uml>>) is shown in <<example_jsonschema_encrule_plainjson>>.

[#example_jsonschema_encrule_plainjson,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a feature type that is converted using the default plain encoding rule
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeG": {
      "$id": "#TypeG",
      "type": "object",
      "properties": {
        "location": {
          "$ref": "http://geojson.org/schema/Point.json"
        },
        "propertyG": {
          "type": "number"
        }
      },
      "required": [
        "location",
        "propertyG"
      ]
    }
  },
  "$ref": "#/definitions/TypeG"
}
----

This JSON object is valid against the schema from <<example_jsonschema_encrule_plainjson>>:

[source,json,linenumbers]
----
{
  "location": {
    "type": "Point",
    "coordinates": [
      8.195669,
      51.903589
    ]
  },
  "propertyG": 3
}
----