[[jsonschema]]
== UML to JSON Schema Encoding


[[jsonschema_introduction]]
=== Introduction

This chapter defines requirements classes for the encoding of application schemas in UML as JSON Schema, and likewise for the encoding of application data as JSON data. 


[[jsonschema_uml_profile]]
=== UML profile

The stereotypes as well as tagged values that are relevant for JSON Schema encodings are listed in <<table_umlprofile_stereotypes>> and <<table_umlprofile_tagged_values>>.

[[table_umlprofile_stereotypes]]
.Stereotypes relevant for JSON Schema encodings
[width="90%",options="header"]
|===
| Stereotype / keyword | Model element | Description
|applicationSchema |Package |A conceptual schema for data required by one or more applications. Source: <<ref_iso19109>>, especially chapter 8.2. 
|schema |Package |This stereotype is typically used in abstract schemas defined by ISO TC 211. For further details on abstract schemas, see <<ref_iso19103>>, chapter 6.2 and figure 4. An abstract schema and an application schema are both conceptual schemas, but they are on different levels of abstraction. The stereotype «Schema» has been introduced for schemas that conform to ISO 19103, but do not follow the rules for application schemas from ISO 19109, but still need a stereotype on the schema package for adding tagged values.
|featureType |Class |A feature type as defined by <<ref_iso19109>>.
|interface |Interface |An abstract classifier with operations, attributes and associations, which can only inherit from or be inherited by other interfaces. Other classifiers may realize an interface by implementing its operations and supporting its attributes and associations (at least through derivation). Source: <<ref_iso19103>> This stereotype is typically used in conceptual schemas from ISO TC 211. It should not be used in application schemas, as these are on a different conceptual level than classifiers with this stereotype.
|dataType |DataType |A set of properties that lack identity (independent existence and the possibility of side effects). A data type is a classifier with no operations, whose primary purpose is to hold information. Source: <<ref_iso19103>>
|union |Class | Either used as __A structured data type without identity where exactly one of the properties of the type is present in an instance__ (property choice) or __type consisting of one and only one of several alternative datatypes__ (type discriminator; source: <<ref_iso19103>>) - in both cases the options are listed as member attributes.
|enumeration |Enumeration |A fixed list of valid identifiers of named literal values. Attributes of an enumerated type may only take values from this list. Source: <<ref_iso19103>>
|codeList |Class |A flexible enumeration that uses string values for expressing a list of potential values. Source: <<ref_iso19103>>
|property |Property (attribute [not of an enumeration or code list] or association role) |A property of a schema type which is not an enumeration or code list.

|===

NOTE: Communities may use aliases for the stereotypes listed above.

NOTE: For backwards-compatibility to UML 1 schemas (that comply with earlier versions of <<ref_iso19103>>), a class with stereotype «Type» can be used instead of an interface.

NOTE: Some conceptual schemas and application schemas do not make use of the stereotypes «property», but still attach certain tagged values to according properties in their UML model. That approach is supported by some UML modeling tools, even though tagged values typically belong to a certain stereotype. For the purposes of this specification, the stereotype «property» is assumed to be applied in schemas that shall be converted from UML to JSON Schema. Nevertheless, it is allowed for schemas to omit the stereotypes, and just use the associated tagged values (see below) on according model elements. This kind of use implies the presence of an ad-hoc stereotype, which is considered to represent the «property» stereotype.

<<table_umlprofile_tagged_values>> lists the tagged values relevant for the JSON Schema encodings, together with the stereotype(s) they apply to, as well as relevant requirements class(es).

[[table_umlprofile_tagged_values]]
.Tagged values relevant for JSON Schema encodings
[width="90%",options="header"]
|===
| Applicable stereotype(s) | Tagged value | Relevant requirements class(es) | Comment
.2+| «applicationSchema» and «schema» | jsonDocument | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] .2+| see <<jsonschema_req_core_definitionsschema>>
| jsonId  | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%]
| «Enumeration» and «CodeList» | literalEncodingType |xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] and xref:http://www.opengis.net/spec/uml2json/1.0/req/codelists-literal[style=id%] | see <<jsonschema_req_core_types_enumeration>> and <<jsonschema_codelists_req_literal>>
.12+| «property» | inlineOrByReference | xref:http://www.opengis.net/spec/uml2json/1.0/req/by-reference-basic[style=id%] | see <<jsonschema_byreference_req_basic>>
| jsonFormat | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] .7+| only relevant for _basic types_, see  <<jsonschema_req_core_types_basictype>>
| jsonPattern | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] 
| maxLength | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] 
| minExclusive | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] 
| minInclusive | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] 
| maxExclusive | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] 
| maxInclusive | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] 
| primaryGeometry | xref:http://www.opengis.net/spec/uml2json/1.0/req/geojson[style=id%] and xref:http://www.opengis.net/spec/uml2json/1.0/req/jsonfg[style=id%] | see <<jsonschema_req_geojson_primary_geometry>> and <<jsonschema_req_jsonfg_primary_geometry>>
| primaryInstant | xref:http://www.opengis.net/spec/uml2json/1.0/req/jsonfg[style=id%] .2+| see <<jsonschema_req_jsonfg_primary_temporal_information>>
| primaryInterval | xref:http://www.opengis.net/spec/uml2json/1.0/req/jsonfg[style=id%]  
| unit | xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%]  | see <<jsonschema_req_core_external_types>>
|===


[[jsonschema_req_core]]
=== Requirements class: Core

include::../requirements/core/requirements_class.adoc[]


[[jsonschema_req_core_definitionsschema]]
==== Definitions schema

Schema packages have the stereotype «applicationSchema», «schema», or an alias (e.g., using a specific language, like in German: «anwendungsschema»). An «applicationSchema» package represents an application schema according to ISO 19109. The stereotype «schema» has been introduced for packages that should be treated like application schemas, but do not contain feature types.

include::../requirements/core/REQ001.adoc[]

NOTE: When encoding the content of an application schema in a single _definitions schema_, it is straightforward to assign the JSON Schema URL whenever such a reference is required for one of the application schema classes. If the content of the application schemas was distributed over multiple _definitions schema_ files, it would be necessary to maintain a mapping for each application schema class, to the URL of the JSON Schema that contains the definition of that class.

NOTE: The "$id" identifies the schema resource with its canonical URI. The URI is an identifier and not necessarily a resolvable URL. If the "$id" is a URL, there is no expectation that the JSON Schema can be downloaded at that URL. 

NOTE: If the value of tag _jsonId_ is a URI with a path to a named file, then the file name given in tag _jsonDocument_ should match the file name in tag _jsonId_. It is not required to do so, because the JSON Schema file can be re-named during the publication process.

include::../requirements/core/REC002.adoc[]

[[example_req_core_jsonschema_definitions_schema]]
.JSON Schema example of a definitions schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$id": "http://example.org/some-definitions-schema.json",
  "$defs": {
    "Class1": {
      "type": "object",
      "properties": {
        "prop1": {"type": "string"}
      },
      "required": ["prop1"]
    },
    "Class2": {
      "type": "object",
      "properties": {
        "prop2": {"type": "number"}
      },
      "required": ["prop2"]
    }
  }
}
----


NOTE: The "$id" of the definitions schema has been omitted in some examples within this chapter. Declaring an absolute, non-existent URL as "$id" in these examples can prevent the examples from working, when testing them using certain JSON Schema validators, for instance on https://www.jsonschemavalidator.net/.

include::../requirements/core/REQ002.adoc[]

[[img_req_core_json_schema_references_between_definitions_schemas]]
.References between JSON Schemas using $ref with JSON pointers as values
image::figures/references_between_definitions_schemas.png[align="center"]

It is up to the encoder to use an absolute or relative URI for a reference to a schema definition within an external JSON Schema file. A reference to a schema definition within the same JSON Schema file should be encoded as a relative URL that consists of a fragment identifier, either using a JSON Pointer (e.g., #/$defs/XYZ) or an anchor (e.g., #XYZ).

[[jsonschema_req_core_definitionsschema_media_types]]
A link to a particular definition within a definitions schema requires the use of a JSON Pointer or an anchor in the fragment identifier of the link URL. <<ref_jsonpointer,JSON Pointer>>, chapter 6, explicitly states that the media type in which a JSON value is provided needs to support this kind of fragment identifier, and that this is not the case for the media type application/json. If a JSON Schema was published with this media type, then it is possible that the application ignores a fragment identifier (because the media type does not support fragment identifiers). If a JSON Schema is published with media type application/schema+json, using anchors and JSON Pointers as fragment identifiers is supported.

The JSON Schema should be published with media type application/schema+json - which is defined by the JSON Schema specification. The media type application/schema+json supports JSON Pointers and plain names as fragment identifiers. For further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02#section-5[JSON Schema core, chapter 5].

// JSON Schema 2019-09 and 2020-12 define another media type identifier (application/schema-instance+json). The "application/schema+json" media type is defined to offer a superset of the fragment identifier syntax and semantics provided by  "application/schema-instance+json". Also see https://ietf-wg-httpapi.github.io/mediatypes/draft-ietf-httpapi-rest-api-mediatypes.html

[NOTE]
======
The JSON Schema with which to validate a JSON document cannot be identified within that document itself. In other words, JSON Schema does not define a concept like an xsi:schemaLocation, which is typically used in an XML document to reference the applicable XML Schema(s). Instead, JSON Schema uses link headers and media type parameters to tie a JSON Schema to a JSON document (for further details, see <<ref_jsonschema_20,JSON Schema core>>, section 9.5). 

Specific formats may encode such links in the JSON data itself. Also see https://ietf-wg-httpapi.github.io/mediatypes/draft-ietf-httpapi-rest-api-mediatypes.html and the "schema" parameter defined there. Some tools (e.g., the oXygen editor) use a "$schema" member in JSON (instance) data to reference the applicable JSON Schema. However, that is a tool-specific approach. In principle, tool-specific approaches are allowed. However, the choice of re-using the "$schema" keyword in that way is problematic, since it does not reflect the intent of "$schema" as defined by <<ref_jsonschema_20,JSON Schema core>>, section 8.1.1. The relationship between a JSON document and the JSON Schema for validation can also be defined explicitly by an application, i.e., in an application specific way.
======


[[jsonschema_req_core_documentation]]
==== Documentation

Descriptive information of application schema elements (packages, classes, attributes and association roles) may be encoded via JSON Schema _annotations_.

[NOTE]
======
_Annotations_ represent one category of JSON Schema keywords (for further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02#section-7[JSON Schema core, section 7]). _Annotations_ attach information that applications can use as they see fit. The other categories are _assertions_, which validate that a JSON instance satsifies constraints, and _applicators_, which apply subschemas to parts of the instance and combine their results.

======

The documentation of an application schema element may be encoded using the JSON Schema "description" annotation. Additional annotations, such as "title" and "examples", may be used as well, where applicable.

[NOTE]
======
Potential reasons for NOT using JSON Schema annotations are:

. Omitting the documentation will result in significantly smaller JSON Schema documents. The reduction of file size is preferable for processes that need to download the schema in order to apply validation. This is even more important if cross-references between JSON Schemas exist.
. When validating JSON data against a JSON Schema, a JSON Schema validator typically focuses on the JSON Schema assertions and applicators, and will ignore most JSON Schema annotations - especially https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9[meta-data annotations], such as "title" and "description."

======


[[jsonschema_req_core_types]]
==== Types


[[jsonschema_req_core_external_types]]
===== External types

Application schemas typically use types from other schemas, for example the types defined by ISO 19103 and ISO 19107. External types can be used as value types of properties, and as supertypes for types defined in the application schema that is being converted.

Whenever an external type is used, its JSON Schema definition is needed. Either an external type is implemented as one of the simple JSON value types (e.g., string - maybe with a certain format or pattern), or it is defined by a particular JSON Schema. In case of a JSON Schema, the URL of that schema needs to be known during the encoding process. If the schema is a definitions schema, then the URL typically needs to be augmented with a fragment identifier that includes a JSON Pointer or an anchor reference within the schema. 

include::../requirements/core/REQ003.adoc[]

[[table_req_core_iso19103_primitive_types]]
.JSON Schema implementation of ISO 19103 primitive types
[width="90%",options="header"]
|===
| UML class | JSON Schema simple type | JSON Schema keywords
|Boolean |boolean |
|CharacterString |string |
|Date |string |format=date
|DateTime |string |format=date-time
|Decimal |number |
|Integer |integer |
|Number |number |
|Real |number |
|Time |string |format=time
|URI |string |format=uri
|===

Some JSON Schema validators do not support or ignore the JSON Schema keyword "format". That can be an issue, especially if a JSON Schema definition represented a choice (e.g., using the JSON Schema keyword "oneOf") between simple JSON Schema types. In that case, such a validator might complain that the choice cannot be made because both options match the simple type definition. The following recommendation is meant to prevent that issue. 

include::../requirements/core/REC003.adoc[]

[[table_req_core_iso19103_patterns]]
.Regular expressions for some ISO 19103 types, to be used in the JSON Schema 'pattern' keyword
[width="90%",options="header"]
|===
| UML class | Regular expression for use in JSON Schema 'pattern' keyword
|Date a|
[source,options="unnumbered"]
----
^\d{4}-\d{2}-\d{2}$
----
|DateTime a| 
[source,options="unnumbered"]
----
^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d)?(Z\|((\+\|-)\d{2}:\d{2}))$
----
|Time a|
[source,options="unnumbered"]
----
^\d{2}:\d{2}:\d{2}(\.\d)?(Z\|((\+\|-)\d{2}:\d{2}))$
----
|URI a|
[source,options="unnumbered"]
----
^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$
----
|===

// EDITORIAL ISSUE Writing regular expressions in table cells can be an issue - see https://github.com/metanorma/metanorma-ogc/issues/466 for details. Using source blocks is a solution. Note that when writing regular expressions in table cells, the cell delimiter character '|' needs to be escaped in the expression!

include::../requirements/core/REQ004.adoc[]

NOTE: Tag _unit_ identifies that the UML property has a fixed unit of measure. Having a fixed unit for a given property is highly beneficial for practical applications, for example when writing queries and filter statements. Note that it is perfectly valid for an application schema to still use a measure type for an attribute with a fixed unit, instead of just type 'Number' or 'Real'. The reason is that the application schema is defined on the conceptual level. From that point of view, a measure typed attribute with a fixed unit still has a measure as value type, not just a number. It is on the implementation level that the simplification of just using a number value for a measure typed property with fixed unit makes sense.

NOTE: If ISO TC 211 defines a JSON Schema for ISO 19103 measure types, then that JSON Schema definition can be used.

NOTE: If an external type is not covered by the mapping tables defined in this document, then a suitable mapping needs be found on a case by case basis. For example, if CI_Citation from ISO 19115 was used by an application schema, a reference to a suitable JSON Schema definition needs to be identified. Such a schema definition could be created manually, or (semi-) automatically, for example using the encoding behavior defined in this specification.


[[jsonschema_req_core_types_classname]]
===== Class name

include::../requirements/core/REQ005.adoc[]

NOTE: Schema definitions that have an "$anchor" can be referenced using the plain text value of the anchor as fragment identifier, instead of using a more complex JSON Pointer.

[[example_req_core_jsonschema_types_classname_anchor]]
.Example of a JSON Schema with $anchor members
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "TypeA": {
      "$anchor": "TypeA",
      "...": "..."
    },
    "TypeB": {
      "$anchor": "TypeB",
      "...": "..."
    }
  }
}
----

Examples of referring to the schema definition of "TypeA" from a "$ref" member:

* within the JSON schema itself:
** using the "$anchor" value: "$ref" = "#TypeA"
** using a JSON Pointer: "$ref" = "#/$defs/TypeA"
* from another JSON Schema:
** using the "$anchor" value: "$ref" = "https://example.org/schemas/schema_definitions.json#TypeA"
** using JSON Pointer: "$ref" = "https://example.org/schemas/schema_definitions.json#/$defs/TypeA"
*** NOTE: If the referenced schema is a draft 07 JSON Schema, the JSON Pointer would have to change as follows: https://example.org/schemas/schema_definitions.json#/definitions/TypeA

NOTE: Keep in mind that the use of a fragment identifier with anchor or JSON Pointer value in $ref references can depend upon the media type with which the referenced JSON schema is published, as is explained in more detail <<jsonschema_req_core_definitionsschema_media_types,here>>.


[[jsonschema_req_core_types_abstractness]]
===== Abstractness

include::../requirements/core/REQ006.adoc[]

NOTE: JSON Schema does not directly support abstractness. 

Encoding an abstract class as a schema definition allows that definition to be referenced from the schema definitions that are created for the subclasses of the abstract class.


[[jsonschema_req_core_types_inheritance]]
===== Inheritance

JSON Schema does not support the concept of inheritance itself. In practice, an inheritance relationship is important in two areas:

* when defining the structure of a subtype, which inherits the properties of its supertypes through the generalization relationships to those supertypes, and
* when using a supertype as UML property value; in that case, subtypes can be used as property value, too, and validation is typically expected to check a value based upon its actual type - especially if a subtype is used as value.

Generalization can be represented in JSON Schemas. Validation of property values that are subtypes of the defined property value type cannot fully be represented in JSON Schema.

include::../requirements/core/REQ007.adoc[]

Multiple inheritance is supported by adding all supertypes as elements of "allOf."

[[img_req_core_json_schema_inheritance_generalization_example]]
.Example of type inheritance
image::figures/Generalization_example.png[align="center"]

[[example_req_core_jsonschema_types_inheritance_generalization]]
.JSON Schema example for realizing generalization using "allOf"
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "TypeA": {
      "properties": {
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "TypeB": {
      "allOf": [
        {
          "$ref": "#/$defs/TypeA"
        },
        {
          "type": "object",
          "properties": {
            "propertyB": {
              "type": "string"
            }
          },
          "required": [
            "propertyB"
          ]
        }
      ]
    }
  },
  "$ref": "#/$defs/TypeB"
}
----

This JSON object is valid against the schema:

[source,json]
----
{
  "propertyA": 2,
  "propertyB": "x"
}
----

This JSON object is invalid (because "propertyA" is missing) against the schema:

[source,json]
----
{
  "propertyB": "x"
}
----

NOTE: This also works for an encoding where the properties of a class are nested within a key-value pair (like "properties" for a GeoJSON encoding).

NOTE: The case where a property from a supertype is redefined by a property from the subtype is supported. Redefinition in UML requires that the value type of the subtype property is "kind of" the type of the redefined property of the supertype. Therefore, the property value, when encoded in JSON, would satisfy the JSON Schema constraints defined by both the subtype property and the redefined supertype property.

This approach to converting a generalization relationship has the following restrictions.

* The JSON Schema keyword "additionalProperties" cannot be set to false in the definitions of both the super- and the subtype.
* The approach is only defined for generalization relationships of feature, object, and data types. For unions, enumerations, and code lists, generalization relationships are not defined by <<ref_iso19103>>.
* It only converts the generalization relationship from subtype to supertype. It does not support the other direction of an inheritance relationship, i.e., specialization. Given a JSON object that encodes a subtype, and the JSON Schema of the supertype, then by validating the JSON object against that JSON Schema, only the constraints of the supertype are checked, but not all the constraints that apply to the subtype. That is an issue when encoding a UML property whose value type is or could be a supertype (via a subtype that is added by an external, so far unknown schema). Conceptually, the actual value of that property can be a supertype object, but it could just as well be an object whose type is a subtype of that supertype. This issue can only be solved to a certain degree with JSON Schema, as explained in <<ref_ugas2020>>, section https://docs.ogc.org/per/20-012.html#jsonschema_schemaconversionrules_types_inheritance_specialization[Class Specialization and Property Ranges].


[[jsonschema_req_core_types_common_base]]
===== Common base schema

It is often useful to encode all classes that have a certain stereotype with a common base type. The generalization relationship to such a base type is often implied with the stereotype, for a given encoding. In GML, for example, the common base type for classes with stereotype «FeatureType» is gml:AbstractFeature. Rather than explicitly modeling such a base type (e.g., _AnyFeature_ defined by ISO 19109), as well as explicitly modeling generalization relationships to the base type, the encoding rule typically takes care of adding that relationship to relevant schema types. Requirements class xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] does not declare specific common base types. That is left to other requirements classes.


[[jsonschema_req_core_types_featureandobjecttype]]
===== Feature and object type

In the conceptual model, feature and object types represent objects that have identity. That differentiates these types from, for example, data types. Other than that, feature and object types - in the following summarily called types with identity - are encoded as JSON objects, just like a data type.

include::../requirements/core/REQ008.adoc[]

NOTE: ISO 19109 requires class names to be unique within the scope of an application schema.

The conversion of the class properties is defined in <<jsonschema_req_core_properties>>. General type conversion rules, such as those documented in <<jsonschema_req_core_types_classname>>, may apply.

The conceptual model of a type with identity often does not contain an identifier property (a UML property whose value for field "isId" is set to true), whose value is used by applications to identify objects of that type. Instead, the according information is added or defined in platform specific encodings. For example, a GML application schema offers the gml:id attribute as well as the gml:identifier element to encode identifying information. In a web publishing context, the URI at which a JSON object is published can be used as its identifier. Requirements class xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] does not declare any specific mechanism for adding an identifier property. That could be achieved through the definition of a common base schema (see <<jsonschema_req_core_types_common_base>>). However, requirements regarding such a base schema are left to other requirements classes. Likewise, this requirements class does not define any requirements regarding the number and characteristics of identifier properties. Again, that is left to other requirements classes.


[[jsonschema_req_core_types_datatype]]
===== Data type

include::../requirements/core/REQ009.adoc[]


[[jsonschema_req_core_types_enumeration]]
===== Enumeration

include::../requirements/core/REQ010.adoc[]

The literal encoding type is one of the types from ISO 19103, which are implemented as a simple JSON Schema type - see <<table_literalencodingtypes>>.

[[table_literalencodingtypes]]
.Literal encoding type
[options="header"]
|====================
| Conceptual type from ISO 19103 | simple JSON Schema type
| CharacterString | string
| Real, Number | number
| Integer | integer
|====================

[[img_req_core_enumeration_example]]
.«Enumeration» example
image::figures/Enumeration_example.png[align="center"]

[[example_req_core_jsonschema_enumeration]]
.Example of enumerations encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Enumeration1": {
      "type": "number",
      "enum": [-5, 0, 5.5]
    },
    "Enumeration2": {
      "type": "string",
      "enum": ["A","B","C"]
    }
  }
}
----


[[jsonschema_req_core_types_basictype]]
===== Basic Type

If a direct or indirect supertype of an application schema class is represented in JSON Schema by one of the simple JSON Schema types _string_, _number_, _integer_, or _boolean_, then that class represents a so called _basic type_. A basic type does not define a JSON object. It represents a simple data value, e.g., a string. The JSON Schema definition of a basic type thus defines a simple JSON Schema type.

include::../requirements/core/REQ011.adoc[]

[[table_req_core_basictypes_restrictions]]
.Basic type restrictions
[options="header"]
|====================
| tagged value (to define a restriction) | JSON Schema keyword | applicable JSON Schema type(s)
| _jsonFormat_ | format | string, number, integer
| _maxLength_ | maxLength | string
| _minLength_ | minLength | string
| _jsonPattern_ | pattern | string
| _minInclusive_ | minimum | number, integer
| _minExclusive_ | exclusiveMinimum | number, integer
| _maxInclusive_ | maximum | number, integer
| _maxExclusive_ | exclusiveMaximum | number, integer
|====================

NOTE: The JSON Schema keyword "format" is defined in chapter 7 of <<ref_jsonschema_20_validation,JSON Schema Validation: A Vocabulary for Structural Validation of JSON>>. The formats defined there (e.g., "date-time", "uri", and "json-pointer") apply to JSON values of type string. Custom formats could apply to JSON values of type number and integer.

NOTE: <<ref_jsonschema_20_validation,JSON Schema Validation: A Vocabulary for Structural Validation of JSON>> defines the JSON Schema keyword "pattern". According to that specification, the value of the keyword should be a regular expression according to the <<ref_ecma262v11>> regular expression dialect. <<ref_jsonschema_20,JSON Schema: A Media Type for Describing JSON Documents>> defines a number of recommendations for writing regular expressions in JSON Schema.

NOTE: If the "format" keyword is used to restrict the structure of a JSON string, so that it matches a certain regular expression, then it is useful to add the "pattern" keyword as well, explicitly defining that regular expression (given that the regular expression follows an <<ref_ecma262v11>> regular expression dialect). The reason is that the "format" is first and foremost an annotation, so can be ignored by JSON Schema validators, whereas the "pattern" keyword will be evaluated by a JSON Schema validator. JSON Schema validators may treat the "format" keyword like an assertion, but that is not guaranteed. In any case, the "format" keyword helps to convey more information about the specific type of a JSON value (e.g., "date" instead of just "string"), and thus should not be omitted if a certain, well-known (i.e., defined by a JSON Schema vocabulary) format is applicable to a JSON value.

<<img_req_core_basictypes_example>> provides a detailed example that illustrates a number of cases. The JSON Schema encoding is shown in <<example_req_core_basictypes>>.

[[img_req_core_basictypes_example]]
.Basic types example
image::figures/basic_types_example.png[align="center"]

[[example_req_core_basictypes]]
.Example of basic types encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "EmailAddress": {
      "allOf": [
        {
          "$ref": "#/$defs/MyCharacterString"
        },
        {
          "format": "email"
        }
      ]
    },
    "MyCharacterString": {
      "type": "string"
    },
    "MyNumber": {
      "type": "number"
    },
    "Number0to360": {
      "allOf": [
        {
          "$ref": "#/$defs/NumberNonNegative"
        },
        {
          "maximum": 360.0
        }
      ]
    },
    "NumberMinus180toPlus180": {
      "allOf": [
        {
          "$ref": "#/$defs/MyNumber"
        },
        {
          "minimum": -180.0,
          "maximum": 180.0
        }
      ]
    },
    "NumberNonNegative": {
      "allOf": [
        {
          "$ref": "#/$defs/NumberOther"
        },
        {
          "minimum": 0.0
        }
      ]
    },
    "NumberOther": {
      "$ref": "#/$defs/MyNumber"
    },
    "String10": {
      "allOf": [
        {
          "type": "string"
        },
        {
          "maxLength": 10
        }
      ]
    },
    "StringPattern": {
      "allOf": [
        {
          "$ref": "#/$defs/MyCharacterString"
        },
        {
          "pattern": "^[abc]{3}$"
        }
      ]
    }
  }
}
----


[[jsonschema_req_core_properties]]
==== Properties


[[jsonschema_req_core_properties_general]]
===== General

include::../requirements/core/REQ012.adoc[]

NOTE: By default, UML properties are converted to keys within the "properties" member of the JSON Schema definition for the type that owns the property. Additional requirements may override this encoding (e.g., the <<jsonschema_unions_req_type_discriminator,type discriminator encoding>> of «union» properties), or augment the encoding (e.g., <<jsonschema_req_geojson_formats_nestedproperties,encoding the properties under the "properties" member of a GeoJSON-based feature>>).

The default result of converting a UML property, therefore, is a key within the "properties" key of the JSON Schema definition for the type that owns the property, with the key name being the name of the UML property, and the value being a JSON Schema with constraints and annotations that define the property (value type, multiplicity, etc).

The following figure and listing provide an example: <<img_req_core_properties_example>> shows a feature type with a number of properties. <<example_req_core_properties_general>> illustrates how the UML properties are represented within the "properties" of the JSON Schema that defines that type.

[[img_req_core_properties_example]]
.UML type used to exemplify JSON Schema encoding of UML properties
image::figures/Properties_example.png[align="center"]

[[example_req_core_properties_general]]
.Encoding UML properties in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "TypeX": {
      "type": "object",
      "properties": {
        "property1": {"type": "string"},
        "property2": {"type": "number"}        
      },
      "required": [
        "property1", "property2"
      ]
    }
  }
}
----


[[jsonschema_req_core_properties_valuetype]]
===== Value Type

include::../requirements/core/REQ016.adoc[]

Examples:

* using the "$anchor" value "TypeX" as fragment identifier: https://example.org/schemas/schema_definitions.json#TypeX
* using JSON Pointer as fragment identifier: https://example.org/schemas/schema_definitions.json#/$defs/TypeX
** NOTE: If the referenced schema is a draft 07 JSON Schema, the JSON Pointer would have to change as follows: https://example.org/schemas/schema_definitions.json#/definitions/TypeX

NOTE: Keep in mind that the use of a fragment identifier with anchor or JSON Pointer value in $ref references can depend upon the media type with which the referenced JSON schema is published, as is explained in more detail <<jsonschema_req_core_definitionsschema_media_types,here>>.

The behavior described in xref:http://www.opengis.net/spec/uml2json/1.0/req/core/property-inline[style=id%] covers the case of an inline encoding of the property value. That is sufficient for simple application schemas. For more complex schemas, typically ones that contain associations between feature types, it can be necessary or desired to encode property values by-reference, i.e., using links. However, multiple options exist for realizing a by-reference encoding. These options are defined in separate requirements classes - see <<jsonschema_byreference>>. A particular JSON Schema encoding of a given application schema needs to choose one of these options, in order to enable by-reference encoding for relevant properties.

[[img_req_core_properties_valuetype_example]]
.Examples of classes from two application schemas with properties that are implemented as simple JSON Schema types and as schema references
image::figures/valuetype_example.png[align="center"]

[[example_req_core_properties_valuetype_schemaa]]
.Example schema A, encoded as JSON Schema
[source,json,linenumbers]
----
include::../code/example_valuetype_schemaA.json[]
----

[[example_req_core_properties_valuetype_schemab]]
.Example schema B, encoded as JSON Schema
[source,json,linenumbers]
----
include::../code/example_valuetype_schemaB.json[]
----

This JSON object is valid against the definition of "Class1" from <<example_req_core_properties_valuetype_schemaa>>:

[source,json]
----
{
  "attBoolean": true,
  "role2_1": {
    "attInteger": 2
  }
}
----

This JSON object is invalid (because "attInteger" has a string value, where an integer value is expected) against the schema from <<example_req_core_properties_valuetype_schemaa>>:

[source,json]
----
{
  "attBoolean": true,
  "role2_1": {
    "attInteger": "X"
  }
}
----


[[jsonschema_req_core_properties_multiplicity]]
===== Multiplicity

include::../requirements/core/REQ013.adoc[]

[[img_req_core_properties_multiplicity_example]]
.UML type used to exemplify JSON Schema encoding of multiplicity
image::figures/Multiplicity_example.png[align="center"]

[[example_req_core_properties_multiplicity]]
.Example for encoding multiplicity in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Type": {
      "type": "object",
      "properties": {
        "property": {
          "type": "array",
          "minItems": 1,
          "maxItems": 2,
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "required": [
        "property"
      ]
    }
  },
  "$ref": "#/$defs/Type"
}
----

This JSON object is valid against the schema from <<example_req_core_properties_multiplicity>>:

[source,json]
----
{
"property": ["a","b"]
}
----

This JSON object is invalid (because "property" has three values, which exceeds the maximum amount of allowed values) against the schema from <<example_req_core_properties_multiplicity>>:

[source,json]
----
{
"property": ["a","b","c"]
}
----

NOTE: All arrays in JSON are ordered, thus that the values of a UML property are ordered is always represented, and that the values of such a property are unordered cannot be represented. However, the latter should not matter to an application that does not expect ordered values for a certain property.


[[jsonschema_req_core_properties_readonly]]
===== Fixed / readOnly

include::../requirements/core/REQ014.adoc[]

[[img_req_core_properties_readonly_example]]
.UML type used to exemplify JSON Schema encoding of a readOnly property
image::figures/example_schemaC_readonly.png[align="center"]

[[example_req_core_properties_readonly]]
.Example for encoding a readOnly property in JSON Schema
[source,json,linenumbers]
----
include::../code/example_readonly.json[]
----


[[jsonschema_req_core_properties_derived]]
===== Derived

include::../requirements/core/REQ015.adoc[]

[[img_req_core_properties_derived_example]]
.UML type used to exemplify JSON Schema encoding of a derived property
image::figures/example_schemaC_derived.png[align="center"]

[[example_req_core_properties_derived]]
.Example for encoding a derived property in JSON Schema
[source,json,linenumbers]
----
include::../code/example_derived.json[]
----


[[jsonschema_req_core_properties_initialvalue]]
===== Initial Value

include::../requirements/core/REQ017.adoc[]
 
NOTE: Theoretically, the default value can also be a JSON array or object, but that cannot be represented in UML and thus is not a relevant use case.

[[img_req_core_properties_initialvalue_example]]
.UML type used to exemplify JSON Schema encoding of properties with initial value
image::figures/example_schemaC_initialvalue.png[align="center"]

[[example_req_core_properties_initialvalue]]
.Example for encoding properties with initial value in JSON Schema
[source,json,linenumbers]
----
include::../code/example_initialvalue.json[]
----


[[jsonschema_req_core_associationclass]]
==== Association class

Standard UML supports the concept of association class, i.e., an association that has properties. There is no native represention for association classes in JSON or JSON Schema. Association classes therefore need to be converted to "intermediate" classes, before being serialized to JSON Schema. The conversion is illustrated in the following figures, with <<img_req_core_association_classes_original>> showing the original conceptual model, and <<img_req_core_association_classes_transformed>> showing the conversion result.

[[img_req_core_association_classes_original]]
.Model with association classes
image::figures/association_classes_original.png[align="center"]

[[img_req_core_association_classes_transformed]]
.Association classes transformed to intermediate classes
image::figures/association_classes_transformed.png[align="center"]

include::../requirements/core/REQ018.adoc[]


[[jsonschema_req_core_constraint]]
==== Constraints

OCL constraints can be used to enrich a conceptual model with requirements that cannot be expressed in UML alone. However, this specification does not define any requirements for converting OCL constraints to JSON Schema definitions, or to any other format with which the constraints can be checked on a JSON dataset.


[[jsonschema_req_core_transformations]]
==== Conceptual model transformations

The conceptual schema may need to be transformed, in order to deal with model elements:

* that cannot be represented in a certain JSON format (e.g., a Solid - a 3D geometry type - as value for the "geometry" member of a GeoJSON feature); or
* that are not (well) supported by client software (e.g., complex attribute values for styling, processing, and filtering).

No specific model transformation requirements and recommendations are defined in this document. Examples of model transformations are given in <<ref_ugas2020>> and in the https://github.com/INSPIRE-MIF/model-transformation-rules[GitHub repository with model transformation rules by the INSPIRE community].


[[jsonschema_req_core_primary_geometry]]
==== Primary geometry

<<ref_ogcapifeatures_part5_schemas>> defines the concept of _primary geometry_:

[quote,OGC API - Features - Part 5: Schemas,"ref_ogcapifeatures_part5_schemas,section=4.1"]
____

*primary geometry*

the geometry that the publisher considers as the most important spatial characteristic of a *feature*

NOTE: A feature can be described by multiple spatial properties. For example, a radio tower can have a property with a point value that describes the location of the tower and another property with a multi-polygon value that describes the area of coverage. Some feature formats can represent only a single geometry per feature. In those cases, the primary geometry will be used when the feature is encoded in such a format.

NOTE: The primary geometry of a feature can also vary depending on the zoom level. At a smaller scale, the primary geometry could be a point while a polygon could be used at a larger scale. 
____

The concept is generally applicable to feature types. Examples of data formats to which the concept applies are GeoJSON and JSON-FG. Requirements regarding the encoding of the primary geometry are defined in the according requirements classes (xref:http://www.opengis.net/spec/uml2json/1.0/req/geojson[style=id%] and xref:http://www.opengis.net/spec/uml2json/1.0/req/jsonfg[style=id%]).

In order to identify the UML property that represents the primary geometry of a feature type, the following approach is used in this specification: 

* If a single (direct or inherited, but ignoring redefined) UML property of the feature type has tag "primaryGeometry" with value equal to and ignoring case "true", then that property is the primary geometry of the feature type.
* Otherwise, if the set of (direct and inherited, but ignoring redefined) UML properties of the feature type only contains a single UML property with a geometric type, and that property is directly owned by the feature type, and that property does not have tag "primaryGeometry" with value equal to, ignoring case, "false", then that property is the primary geometry of the feature type.
* Otherwise, no primary geometry is defined for the feature type.

NOTE: A feature type that has multiple UML properties with tag "primaryGeometry" = true is not modeled correctly.

NOTE: Setting tagged value "primaryGeometry" = false can be useful in cases of geometric properties of classes that are (expected to be) subtyped, with the subtypes defining their own primary geometry properties. If the supertype had a geometric property without such a tagged value, the second part of the rule (for determining the primary geometry) would apply, thereby incorrectly identifying the supertype property as primary geometry. That can lead to undesired JSON Schema constraints. 


[[jsonschema_req_core_primary_tempinfo]]
==== Primary temporal information

<<ref_ogcapifeatures_part5_schemas>> defines the concept of _primary temporal information_:

[quote,OGC API - Features - Part 5: Schemas,"ref_ogcapifeatures_part5_schemas,section=4.1"]
____

*primary temporal information*

the time instant or time interval that the publisher considers as the most important temporal characteristic of a *feature*

NOTE: A feature can be described by multiple temporal properties. For example, an event can have a property with an instant or interval when the event occurred or will occur and another property when the event was recorded in the dataset. The primary temporal information can also be built from two properties, e.g., when the feature has two properties describing the start and end instants of an interval. 
____

The concept is generally applicable to feature types. An example of a data format to which the concept applies is JSON-FG. Requirements regarding the encoding of primary temporal information are defined in the according requirements class (xref:http://www.opengis.net/spec/uml2json/1.0/req/jsonfg[style=id%]).

In order to identify the UML property that represents the primary geometry of a feature type, the following approach is used in this specification:

* A UML property that is owned by the feature type and that has tag "primaryInstant" with value equal to and ignoring case "true" is the primary-instant of the feature type.
* A UML property that is owned by the feature type and that has tag "primaryInterval" with value equal to and ignoring case:
** "interval" is the primary-interval of the feature type.
** "start" is the primary-interval-start of the feature type.
** "end" is the primary-interval-end of the feature type.
  
NOTE: The value types of UML properties that represent or contribute to the primary interval should be compatible with that use. For example, properties marked as primary-interval-start or primary-interval-end can have value type "Date", "DateTime", or "TM_Instant", whereas a property marked as primary-interval can have value type "TM_Period".
  
[NOTE]
======
A feature type that does not satisfy the following conditions is not modeled correctly:

* At most one of the (direct or inherited, but ignoring redefined) properties has tag "primaryInterval" = "interval".
* At most one of the (direct or inherited, but ignoring redefined) properties has tag "primaryInterval" = "start".
* At most one of the (direct or inherited, but ignoring redefined) properties has tag "primaryInterval" = "end".
* The use of "interval" and "start"/"end" are mutually exclusive within the (direct or inherited, but ignoring redefined) properties of the feature type: 
** If one property has tag "primaryInterval" = "interval", then no other property has tag "primaryInterval" equal to "start" or "end". 
** Likewise, if one property has tag "primaryInterval" equal to "start" or "end", then no other property has tag "primaryInterval" = "interval".
======


[[jsonschema_req_plain]]
=== Requirements class: Encoding rule for a plain JSON Schema format

include::../requirements/plain/requirements_class.adoc[]

NOTE: An example of an application schema encoded in plain JSON Schema format is given in <<annex_example_application_schema_plain>>.


[[jsonschema_req_plain_common_base]]
==== Common base schema

As described in the <<jsonschema_req_core_types_common_base,core requirements class>>, common base types or - for the purposes of this encoding rule - common JSON Schema definitions can be added to the schema definition of certain kinds of classes, for example, all feature types. This requirements class does not specify any such common JSON Schema definitions. As a consequence, if the types with identity defined by an application schema do not contain attributes that convey the identity of an actual object, according JSON objects cannot be identified using information from property values. Additional requirements classes, which depend on xref:http://www.opengis.net/spec/uml2json/1.0/req/plain[style=id%], may add requirements regarding a common base.


[[jsonschema_req_plain_iso19107_types]]
==== Implementation of ISO 19107 types

include::../requirements/plain/REC001.adoc[]

[[table_plain_iso19107_types]]
.JSON Schema implementation of types defined by ISO 19107 for the plain JSON Schema encoding rule
[width="90%",options="header"]
|===
| UML class | JSON Schema reference
|GM_Point |https://geojson.org/schema/Point.json
|GM_Curve |https://geojson.org/schema/LineString.json
|GM_Surface |https://geojson.org/schema/Polygon.json
|GM_MultiPoint |https://geojson.org/schema/MultiPoint.json
|GM_MultiCurve |https://geojson.org/schema/MultiLineString.json
|GM_MultiSurface |https://geojson.org/schema/MultiPolygon.json
|GM_Aggregate |https://geojson.org/schema/GeometryCollection.json
|GM_Object |https://geojson.org/schema/Geometry.json

|===

NOTE: <<table_plain_iso19107_types>> uses geometry types defined by <<ref_iso19107>>. While this specification does not define mapping tables for newer versions of ISO 19107, application schemas may use geometry types from a newer version of ISO 19107. The mappings would then need to be adjusted accordingly (finding correct replacements for the types mentioned in the first column of the table).

NOTE: For geometry typed properties whose value type is not covered in <<table_plain_iso19107_types>>, a suitable mapping needs to be defined, as explained in <<jsonschema_req_core_external_types>>.

NOTE: Other geometry encodings are allowed for the plain JSON Schema format, for example a WKT string or a JSON-FG geometry. Such geometry encodings may be useful in application scenarios where tools do not (only) support GeoJSON.

[[jsonschema_req_plain_identifier]]
==== Identifier property

This requirements class does not define a means to add an identifier property - i.e., a UML property that is modeled with "isId" = true - to the JSON Schema encoding of a feature type, if that type does not declare such a property. The application schema would need to be transformed, in order to add an identifier property, where necessary.


[[jsonschema_req_geojson_formats]]
=== Requirements class: GeoJSON Formats

include::../requirements/geojson-formats/requirements_class.adoc[]

[[jsonschema_req_geojson_formats_identifier]]
==== Identifier property

include::../requirements/geojson-formats/REQ001.adoc[]

NOTE: A UML property of a feature type which is modeled with "isId" = true, is mapped to the "id" member of a GeoJSON feature. The mapping algorithm is community-specific. If a feature type has multiple UML properties where "isId" = true, or if the value type of such a property is not a simple type, some community specific conversion mechanism needs to be defined, for mapping the identifier value(s) to a simple string or number, which can be used as value of the "id" member of a GeoJSON feature.

NOTE: The UML properties with "isId" = true are encoded as any other property, in addition to being mapped to the top-level "id" member. That is especially useful in case multiple such properties exist in a feature type, because applications that know the conceptual schema can read these dedicated properties directly, in order to gather information about the ID of a given feature, rather than having to decode the "id" member.


[[jsonschema_req_geojson_formats_nestedproperties]]
==== Nesting feature type properties

include::../requirements/geojson-formats/REQ002.adoc[]

NOTE: Additional requirements can override this behavior, by omitting certain UML properties or by mapping certain UML properties to first-level members of the resulting JSON object. An example is the  <<jsonschema_req_geojson_formats_identifier,identifier property>>.

NOTE: Properties of object types are encoded as first-level properties of the resulting JSON object. If object types should be encoded as feature types, then the object types would need to be transformed accordingly, before a JSON Schema encoding is created.


[[jsonschema_req_geojson]]
=== Requirements class: Encoding rule for a GeoJSON compliant JSON Schema format

include::../requirements/geojson/requirements_class.adoc[]

NOTE: An example of an application schema encoded in GeoJSON compliant JSON Schema format is given in <<annex_example_application_schema_geojson>>.


[[jsonschema_req_geojson_common_base]]
==== Common base schema

As described in the <<jsonschema_req_core_types_common_base,core requirements class>>, common base types or - for the purposes of this encoding rule - common JSON Schema definitions can be added to the schema definition of certain kinds of classes, for example, all feature types.

include::../requirements/geojson/REQ001.adoc[]

NOTE: No common base schema is defined for object types. Such types need to be transformed to feature types if they should be encoded as GeoJSON features.

<<img_req_geojson_common_base_example>> illustrates a feature type hierarchy, and <<example_req_geojson_common_base>> shows how these feature types are encoded in JSON Schema using the common base schema. Note that the definitions of the individual feature types still state "type": "object" in order to illustrate the place where object properties would be defined. However, such properties have been omitted in the example to avoid unnecessary complexity.

[[img_req_geojson_common_base_example]]
.Example of a feature type hierarchy in an application schema
image::figures/example_common_base.png[align="center"]

[[example_req_geojson_common_base]]
.Example for encoding the common base schema for feature types
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "http://example.org/schema/infra.json",
  "$defs": {
    "Building": {
      "$anchor": "Building",
      "allOf": [
        {
          "$ref": "#/$defs/Building_Core"
        },
        {
          "type": "object"
        }
      ]
    },
    "BuildingPart": {
      "$anchor": "BuildingPart",
      "allOf": [
        {
          "$ref": "#/$defs/Building_Core"
        },
        {
          "type": "object"
        }
      ]
    },
    "Building_Core": {
      "$anchor": "Building_Core",
      "allOf": [
        {
          "$ref": "https://geojson.org/schema/Feature.json"
        },
        {
          "type": "object"
        }
      ]
    },
    "Parcel": {
      "$anchor": "Parcel",
      "allOf": [
        {
          "$ref": "https://geojson.org/schema/Feature.json"
        },
        {
          "type": "object"
        }
      ]
    }
  }
}
----

[[jsonschema_req_geojson_iso19107_types]]
==== Implementation of ISO 19107 types for the "geometry" member

include::../requirements/geojson/REQ002.adoc[]

[[table_iso19107_types_geometry_member]]
.JSON Schema implementation of types defined by ISO 19107, for the "geometry" member in the GeoJSON encoding rule
[width="90%",options="header"]
|===
| UML class | JSON Schema reference
|GM_Point |https://geojson.org/schema/Point.json
|GM_Curve |https://geojson.org/schema/LineString.json
|GM_Surface |https://geojson.org/schema/Polygon.json
|GM_MultiPoint |https://geojson.org/schema/MultiPoint.json
|GM_MultiCurve |https://geojson.org/schema/MultiLineString.json
|GM_MultiSurface |https://geojson.org/schema/MultiPolygon.json
|GM_Aggregate |https://geojson.org/schema/GeometryCollection.json
|GM_Object |https://geojson.org/schema/Geometry.json

|===

NOTE: <<table_iso19107_types_geometry_member>> uses geometry types defined by <<ref_iso19107>>. While this specification does not define mapping tables for newer versions of ISO 19107, application schemas may use geometry types from a newer version of ISO 19107. The mappings would then need to be adjusted accordingly (finding correct replacements for the types mentioned in the first column of the table).

NOTE: For geometry typed properties that are not mapped to the "geometry" top-level member, a suitable mapping needs to be defined, as explained in <<jsonschema_req_core_external_types>>.


[[jsonschema_req_geojson_primary_geometry]]
==== Primary geometry

include::../requirements/geojson/REQ003.adoc[]

NOTE: UML properties of other kinds of classes - object types, data types, and unions - are not considered by this requirement. Object types are not encoded as GeoJSON features. Data types and unions may be used by other classes, which prevents a general exclusive mapping to the GeoJSON top-level "geometry" member. Only a direct property of a «FeatureType» can be mapped in this way.

[[img_req_geojson_primary_geometry_example]]
.Example of a feature type with an attribute designated as primary geometry
image::figures/example_primary_geometry.png[align="center"]

[[example_req_geojson_primary_geometry]]
.Example for encoding a feature type with primary geometry
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {    
    "Parcel": {
      "$anchor": "Parcel",
      "allOf": [
        {
          "$ref": "https://geojson.org/schema/Feature.json"
        },
        {
          "type": "object",
          "properties": {
            "geometry": {
              "$ref": "https://geojson.org/schema/Polygon.json"
            }
          }
        }
      ]
    }
  }
}
----


[[jsonschema_req_jsonfg]]
=== Requirements class: Encoding rule for a JSON-FG compliant JSON Schema format

include::../requirements/jsonfg/requirements_class.adoc[]

NOTE: An example of an application schema encoded in JSON-FG compliant JSON Schema format is given in <<annex_example_application_schema_jsonfg>>.


[[jsonschema_req_jsonfg_common_base]]
==== Common base schema

As described in the <<jsonschema_req_core_types_common_base,core requirements class>>, common base types or - for the purposes of this encoding rule - common JSON Schema definitions can be added to the schema definition of certain kinds of classes, for example, all feature types.

include::../requirements/jsonfg/REQ001.adoc[]

NOTE: No common base schema is defined for object types. Such types need to be transformed to feature types if they should be encoded as JSON-FG features.

An example of encoding feature types with a common base schema is given in <<jsonschema_req_geojson_common_base>>. It can easily be adapted to match xref:http://www.opengis.net/spec/uml2json/1.0/req/jsonfg/common-base[style=id%] by exchanging "https://geojson.org/schema/Feature.json" with "https://beta.schemas.opengis.net/json-fg/feature.json".


[[jsonschema_req_jsonfg_iso19107_types]]
==== Implementation of ISO 19107 types for the "place" member

include::../requirements/jsonfg/REQ002.adoc[]

[[table_iso19107_types_place_member]]
.JSON Schema implementation of types defined by ISO 19107, for the "place" member
[width="90%",options="header"]
|===
| UML class | JSON Schema reference
|GM_Point |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/Point
|GM_Curve |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/LineString
|GM_Surface |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/Polygon
|GM_Solid |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/Polyhedron
|GM_MultiPoint |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/MultiPoint
|GM_MultiCurve |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/MultiLineString
|GM_MultiSurface |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/MultiPolygon
|GM_MultiSolid |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/MultiPolyhedron
|GM_Aggregate |https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/GeometryCollection
|GM_Object |https://beta.schemas.opengis.net/json-fg/geometry.json

|===

NOTE: <<table_iso19107_types_place_member>> uses geometry types defined by <<ref_iso19107>>. While this specification does not define mapping tables for newer versions of ISO 19107, application schemas may use geometry types from a newer version of ISO 19107. The mappings would then need to be adjusted accordingly (finding correct replacements for the types mentioned in the first column of the table).

NOTE: For geometry typed properties that are not mapped to the "place" top-level member, a suitable mapping needs to be defined, as explained in <<jsonschema_req_core_external_types>>.


[[jsonschema_req_jsonfg_primary_geometry]]
==== Primary geometry

include::../requirements/jsonfg/REQ003.adoc[]

NOTE: In instance data, the value of such a property is typically encoded within the (JSON-FG) top-level "place" member of the JSON object that represents the «FeatureType». However, there can also be cases where the value is encoded in the top-level "geometry" member. For further details, see <<ref_jsonfg>>, section "7.5 Geometry".

NOTE: UML properties of other kinds of classes - object types, data types, and unions - are not considered by this requirement. Object types are not encoded as JSON-FG features. Data types and unions may be used by other classes, which prevents a general exclusive mapping to the JSON-FG top-level "place" member. Only a direct property of a «FeatureType» can be mapped in this way.

[[img_req_jsonfg_primary_place_example]]
.Example of a feature type with an attribute designated as primary place
image::figures/example_primary_geometry_2.png[align="center"]

[[example_req_jsonfg_primary_place]]
.Example for encoding a feature type with primary place
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "BuildingPart": {
      "$anchor": "BuildingPart",
      "allOf": [
        {
          "$ref": "http://example.org/schema/infra.json#Building_Core"
        },
        {
          "type": "object",
          "properties": {
            "place": {
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "https://beta.schemas.opengis.net/json-fg/geometry-objects.json#/$defs/Polyhedron"
                }
              ]
            }
          }
        }
      ]
    }
  }
}
----


[[jsonschema_req_jsonfg_primary_temporal_information]]
==== Primary temporal information

include::../requirements/jsonfg/REQ004.adoc[]

NOTE: UML properties of other kinds of classes - object types, data types, and unions - are not considered by this requirement. Object types are not encoded as JSON-FG features. Data types and unions may be used by other classes, which prevents a general exclusive mapping to the JSON-FG top-level "time" member. Only a direct property of a feature type can be mapped in this way.

[[img_req_jsonfg_primary_time_example]]
.Example of a feature type with an attribute designated as primary instant
image::figures/example_primary_instant.png[align="center"]

[[example_req_jsonfg_primary_time]]
.Example for encoding a feature type with primary instant
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Building_Core": {
      "$anchor": "Building_Core",
      "allOf": [
        {
          "$ref": "https://beta.schemas.opengis.net/json-fg/feature.json"
        },
        {
          "type": "object"
        }
      ]
    }
  }
}
----


[[jsonschema_byreference]]
=== Additional requirements classes for the by-reference encoding of property values

==== Overview

Requirements class xref:http://www.opengis.net/spec/uml2json/1.0/req/core[style=id%] specifies an <<jsonschema_req_core_properties_valuetype,inline encoding of property values>>. In the case that the value type of a UML property is a type with identity (that is not implemented as a simple JSON Schema type), it can be preferable and maybe even necessary to encode the value by reference. In other cases, both options should be offered. That is similar to what the GML Application Schema encoding rules support (for further details, see OGC 07-036r1, Annex E, section E.2.4.11).

NOTE: An example where a reference to an object is needed, is when the object is the value of properties from multiple other objects that are encoded within the same JSON document. For example, a feature referenced from several other features. In such a situation, it is often desirable not to encode the object inline multiple times - especially if that object also references other objects.

NOTE: Some applications may prefer to reference types with identity using a code (of type string or number) instead of using a URI. That code could be seen as a foreign key. In such cases, a model transformation should be applied first, which, for all relevant properties whose value type is a type with identity, replaces the value type with _CharacterString_ or __Number__.

Multiple options exist for realizing the by-reference encoding of property values. A requirements class is available for each option:

* xref:http://www.opengis.net/spec/uml2json/1.0/req/by-reference-uri[style=id%] - by-reference encoding of property values using a plain URI (reference, i.e., an absolute or relative URI)
* xref:http://www.opengis.net/spec/uml2json/1.0/req/by-reference-link-object[style=id%] - by-reference encoding of property values using a link object

NOTE: The conversion behavior does not support by reference encoding for value types that are data types. In general, a data type does not have identity, and therefore a data type value should always be encoded inline, not by reference. 

// Likely irrelevant for the Best Practice: The XML Schema encoding rule defined by ISO 19139:2007, typically used to encode metadata schemas (as defined by ISO 19115, and extensions thereof), on the other hand, allows by reference encoding for data type values. When comparing the version of ISO 19115 from 2003/2006 against the version from 2014, it is apparent that some classes that were defined as data types in the previous version have been changed to object types, for example _CI_Citation_. This indicates that the assignment of the «DataType» stereotype has been corrected, in order to reflect in the conceptual model that the type shall be a type with identity.

// Interestingly, there is an early activity of standardizing or harmonizing references in JSON: https://github.com/json-schema-org/referencing. However, that activity is still ongoing (as of November, 2022) and there are competing proposals.


[[jsonschema_byreference_req_basic]]
==== Requirements class: basics for the by-reference encoding of property values

include::../requirements/by-reference-basic/requirements_class.adoc[]

include::../requirements/by-reference-basic/REQ001.adoc[]

NOTE: The default value for tag _inlineOrByReference_ is different in GML. For the JSON Schema encoding, the default values have been chosen in order to reduce the degrees of freedom and to reduce the schema complexity. The separation into default value _inline_ for UML attributes, and _byReference_ for UML association roles has been made since that reflects the typical modeling approach, where association roles have a value type that is usually encoded by reference, and attributes have a value type that is usually encoded inline - especially if the attribute value type is a type with identity (e.g., an ISO 19107 geometry type).


[[jsonschema_byreference_encoding_req_uri]]
==== Requirements class: by-reference encoding of property values using a plain URI reference

include::../requirements/by-reference-uri/requirements_class.adoc[]

include::../requirements/by-reference-uri/REQ001.adoc[]

NOTE: The result is an XOR type of check, i.e., a value can either be given inline or by reference, but not both. This is different to GML, where in the case of _inlineOrByReference_ and a type with identity as value type, a value can be encoded both inline and by reference.

[[img_req_by_reference_example]]
.Example of an association between two feature types, where the association roles are to be encoded by reference
image::figures/example_byreference.png[align="center"]

The JSON Schema encoding for the example in <<img_req_by_reference_example>>, using URIs to realize by-reference encoding of property values, is given in <<example_req_byreference_uri>>.

[[example_req_byreference_uri]]
.Example for encoding association roles by-reference using URIs
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Parcel": {
      "$anchor": "Parcel",
      "type": "object",
      "properties": {        
        "owner": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "string",
            "format": "uri-reference"
          },
          "uniqueItems": true
        }
      },
      "required": [
        "owner"
      ]
    },
    "Person": {
      "$anchor": "Person",
      "type": "object",
      "properties": {        
        "owns": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uri-reference"
          },
          "uniqueItems": true
        }
      }
    }
  }
}
----

This JSON object is valid against the schema definition of "Parcel" from <<example_req_byreference_uri>>:

[source,json]
----
{  
  "owner": ["http://example.org/Person/d024i42sl"]
}
----


[[jsonschema_byreference_encoding_req_link_object]]
==== Requirements class: by-reference encoding of property values using a link object

include::../requirements/by-reference-link-object/requirements_class.adoc[]

include::../requirements/by-reference-link-object/REQ001.adoc[]

NOTE: The result is an XOR type of check, i.e., a value can either be given inline or by reference, but not both. This is different to GML, where in the case of _inlineOrByReference_ and a type with identity as value type, a value can be encoded both inline and by reference.

// link object is most "webby" ... maybe link to discussion in JSON-FG Annex about linking

The JSON Schema encoding for the example in <<img_req_by_reference_example>>, using link objects to realize by-reference encoding of property values, is given in <<example_req_byreference_link_object>>.

[[example_req_byreference_link_object]]
.Example for encoding association roles by-reference using link objects
[source,json,linenumbers]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Parcel": {
      "$anchor": "Parcel",
      "type": "object",
      "properties": {        
        "owner": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "https://register.geostandaarden.nl/jsonschema/uml2json/0.1/schema_definitions.json#/$defs/LinkObject"
          },
          "uniqueItems": true
        }
      },
      "required": [
        "owner"
      ]
    },
    "Person": {
      "$anchor": "Person",
      "type": "object",
      "properties": {        
        "owns": {
          "type": "array",
          "items": {
            "$ref": "https://register.geostandaarden.nl/jsonschema/uml2json/0.1/schema_definitions.json#/$defs/LinkObject"
          },
          "uniqueItems": true
        }
      }
    }
  }
}
----

This JSON object is valid against the schema definition of "Parcel" from <<example_req_byreference_link_object>>:

[source,json]
----
{
  "owner": [
    {
      "title": "John Doe",
      "href": "http://example.org/Person/d024i42sl"
    }
  ]  
}
----


[[jsonschema_unions]]
=== Additional requirements classes for the encoding of union types

[[jsonschema_unions_overview]]
==== Overview

Application schemas have two ways of using types with stereotype «union».

* According to ISO 19103:2015, a «union» type consists __"of one and only one of several alternative datatypes (listed as member attributes). This is similar to a discriminated union in many programming languages"__. According to this definition, only the types of the UML attributes defined for a «union» are of interest.
* In practice, unions defined in application schemas are also used differently, defining a choice between a number of options, where each option is modeled as a UML attribute. In other words, the attribute itself has meaning - not just its value type. Multiple options can have the same value type. Options can have different maximum multiplicity (especially greater than 1). The UML-to-GML application schema encoding rules support this way of using unions (see OGC 07-036r1, section E.2.4.10).

The following sections document requirements classes for union encodings that support these two approaches.


[[jsonschema_unions_req_type_discriminator]]
==== Requirements class: JSON Schema encoding for unions representing type discriminators

include::../requirements/union-type-discriminator/requirements_class.adoc[]

include::../requirements/union-type-discriminator/REQ001.adoc[]

The result of applying this encoding to the unions from <<img_unions_req_type_discriminator_union_example>> is shown in <<example_unions_req_type_discriminator_jsonschema>>.

[[img_unions_req_type_discriminator_union_example]]
.Example of type discriminator unions
image::figures/type_discriminator_unions.png[align="center"]

[[example_unions_req_type_discriminator_jsonschema]]
.Example of a JSON Schema for unions, encoding them as type discriminators
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Union_TypeDiscriminator": {
      "oneOf": [
        {
          "type": [
            "string",
            "integer"
          ]
        },
        {
          "$ref": "https://geojson.org/schema/Point.json"
        }
      ]
    },
    "Union_TypeDiscriminator_OtherTypes": {
      "oneOf": [
        {
          "$ref": "https://geojson.org/schema/LineString.json"
        },
        {
          "$ref": "https://geojson.org/schema/Point.json"
        }
      ]
    },
    "Union_TypeDiscriminator_SimpleTypes": {
      "type": [
        "string",
        "integer"
      ]
    }
  }
}
----

WARNING: Care must be taken, that the type choices of a type discriminator union are separate value spaces. Otherwise, validation may fail, if an actual value matches more than one of the type choices. That would break the rule of the "oneOf" JSON Schema keyword, that one and only one of its component schemas is satisfied. If, for example, the "Union_TypeDiscriminator" in <<example_unions_req_type_discriminator_jsonschema>> had another option for a date value ("type": "string", "format": "date"), and value "2022-12-09" was validated against the resulting JSON Schema definition, validation would fail - because that value matches both the string-or-number case and the string-with-format-date case.


[[jsonschema_unions_req_property_choice]]
==== Requirements class: JSON Schema encoding for unions representing property choices

include::../requirements/union-property-choice/requirements_class.adoc[]

include::../requirements/union-property-choice/REQ001.adoc[]

The result of applying this encoding to the union from <<img_unions_req_property_choice_union_example>> is shown in <<example_unions_req_property_choice_jsonschema>>.

[[img_unions_req_property_choice_union_example]]
.«union» example
image::figures/Union_example.png[align="center"]

[[example_unions_req_property_choice_jsonschema]]
.Example of a JSON Schema for a «union» class, representing the property choice using "minProperties" and "maxProperites"
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "UnionA": {
      "type": "object",
      "properties": {
        "option1": {
          "type": "string"
        },
        "option2": {
          "type": "number"
        }
      },
      "additionalProperties": false,
      "minProperties": 1,
      "maxProperties": 1
    }
  },
  "$ref": "#/$defs/UnionA"
}
----

NOTE: An alternative approach would be using the "oneOf" keyword, with one subschema per union property, which only defines that property, and requires it (but does not perform any other checks). This option is more verbose, harder to read and understand and, therefore, not recommended.

This JSON object is valid against the schema:

[source,json]
----
{
  "option1": "x"
}
----

This JSON object is invalid (because "option2" has a string value, rather than a numeric value) against the schema:

[source,json]
----
{
  "option2": "x"
}
----


[[jsonschema_codelists]]
=== Additional requirements classes for the encoding of code list types

==== Overview

This specification defines three approaches for encoding the values of properties that have a «CodeList» as value type:

* using a simple literal value, e.g., a string or number that represents a code,
* using a URI as code value, and
* using a link object to link to a code representation.

The following sections document requirements classes for code list encodings that support these three approaches. All of them inherit requirements from a common requirements class, which is defined in <<jsonschema_codelists_req_basic>>.


[[jsonschema_codelists_req_basic]]
==== Requirements class: Basic JSON Schema encoding for code lists

include::../requirements/codelists-basic/requirements_class.adoc[]

include::../requirements/codelists-basic/REQ001.adoc[]

include::../requirements/codelists-basic/REQ002.adoc[]

[[img_codelists_req_basic_jsonschema_example]]
.Example of a «CodeList» type with tagged value 'codeList'
image::figures/code_lists_basic.png[align="center"]

[[example_codelists_req_basic_jsonschema]]
.Example of the basic JSON Schema encoding of a «CodeList» type with tagged value 'codeList'
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "SomeCodelist": {
      ...
      "codeList": "http://example.org/codelists/SomeCodelist",
      ...
    }
  }
}
----


[[jsonschema_codelists_req_literal]]
==== Requirements class: JSON Schema encoding for code lists - literal

include::../requirements/codelists-literal/requirements_class.adoc[]

include::../requirements/codelists-literal/REQ001.adoc[]

The literal encoding type is one of the types from ISO 19103, which are implemented as a simple JSON Schema type - see <<table_literalencodingtypes>> in <<jsonschema_req_core_types_enumeration>>.

[[img_codelists_req_literal_jsonschema_example]]
.Example of «CodeList» types
image::figures/code_lists_literal.png[align="center"]

[[example_codelists_req_literal_jsonschema]]
.Example of the JSON Schema encodings of «CodeList» types
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "CodelistNumeric": {
      "type": "number"
    },
    "CodelistString": {
      "type": "string"
    }
  }
}
----


[[jsonschema_codelists_req_uri]]
==== Requirements class: JSON Schema encoding for code lists - URI

include::../requirements/codelists-uri/requirements_class.adoc[]

include::../requirements/codelists-uri/REQ001.adoc[]

[[example_codelists_req_uri_jsonschema]]
.Example of the JSON Schema encodings of a «CodeList» type with the JSON Schema "type" being a URI
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "CodelistUriFormat": {
      "type": "string",
      "format": "uri"
    }
  }
}
----


[[jsonschema_codelists_req_link_object]]
==== Requirements class: JSON Schema encoding for code lists - link object

include::../requirements/codelists-link-object/requirements_class.adoc[]

include::../requirements/codelists-link-object/REQ001.adoc[]

That means that a code value is essentially encoded as a "link object" as specified by IETF RFC 8288 and implemented in the OGC API standards. The link object provides "href" and "title" members like the simple Xlinks in GML.
 

[[jsonschema_req_entitytype]]
=== Requirements class: Encoding of an additional entityType property

include::../requirements/entitytype/requirements_class.adoc[]

include::../requirements/entitytype/REQ001.adoc[]

include::../requirements/entitytype/PER001.adoc[]

NOTE: By default, the property value is not restricted using "const", because doing so would prevent JSON Schema constraints that support inheritance-related checks. However, if the application schema did not use inheritance, then such restrictions could be defined.

NOTE: Encoding the type name in JSON objects can be useful, since, as described in http://docs.opengeospatial.org/per/18-091r2.html#JSON_LD[chapter 6 of the OGC Testbed-14: Application Schemas and JSON Technologies Engineering Report], having a key within a JSON object with a string value that identifies the type of the object allows that object to be mapped to RDF. More specifically, the string value can be mapped to an IRI that identifies the type of an RDFS resource.

NOTE: Encoding a JSON object that represents an abstract type, with the "entityType" having the abstract type name as value, would be useful with regards to linked data applications, and conversion of JSON data to RDF using JSON-LD. Abstractness is also not supported in RDF/OWL, so RDF resources can define the RDFS/OWL class or datatype, which represent an abstract type from the conceptual model, as their type. That makes sense for cases in which the exact type of a resource or "thing" is not known yet, but a more general type is.

[[example_req_entitytype_jsonschema]]
.JSON Schema example with property "entityType" used for identifying the type of a JSON object
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "Person": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "entityType", "name"
      ]
    }
  },
  "$ref": "#/$defs/Person"
}
----

The following JSON instance is valid against the schema:

[source,json]
----
{
  "entityType": "Person",
  "name": "John Doe"
}
----
