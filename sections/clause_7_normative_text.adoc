// == Clause containing normative material

// Paragraph

// === Requirement Class A or Requirement A Example

// Paragraph – intro text for the requirement class.

// Use the following table for Requirements Classes.

// include::../requirements/requirements_class.adoc[]

// ==== Requirement 1

// Paragraph - intro text for the requirement.

// Use the following table for Requirements, number sequentially.

// include::../requirements/requirement.adoc[]

// Dictionary tables for requirements can be added as necessary. Modify the following example as needed.

// [width="90%",options="header"]
// |===
// |Names |Definition |Data types and values |Multiplicity and use
// |name 1 |definition of name 1 |float |One or more (mandatory)
// |name 2 |definition of name 2 |character string type, not empty |Zero or one (optional)
// |name 3 |definition of name 3 |GML:: Point PropertyType |One (mandatory)
// |===
[[jsonschema]]
== UML to JSON Schema Encoding Rules

[[jsonschema_schemaconversionrules]]
=== Schema Conversion Rules

The following subsections describe a number of conversion rules, which define how the content of an application schema, represented using UML as the conceptual schema language, is converted to JSON Schema.

NOTE: An encoding rule consists of a set of conversion rules – as required by a community. The <<jsonschema_encodingrules>> section describes two such rules - one for a GeoJSON compliant encoding, and one for a plain JSON encoding.

[[jsonschema_schemaconversionrules_documentation]]
==== Documentation

Descriptive information of application schema elements (packages, classes, attributes and association roles) MAY be encoded via JSON Schema _annotations_.

[NOTE]
======
_Annotations_ represent one category of JSON Schema keywords (for further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02#section-7[JSON Schema core, section 7]). _Annotations_ attach information that applications may use as they see fit. The other categories are _assertions_, which validate that a JSON instance satsifies constraints, and _applicators_, which apply subschemas to parts of the instance and combine their results.

======

The documentation of an application schema element MAY be encoded using the JSON Schema "description" annotation. Additional annotations, such as "title" and "examples", MAY be used as well, where applicable.

[NOTE]
======
Potential reasons for NOT using JSON Schema annotations are:

. Omitting the documentation will result in significantly smaller JSON Schema documents. The reduction of file size is preferable for processes that need to download the schema in order to apply validation. This is even more important if cross-references between JSON Schemas exist.
. When validating JSON data against a JSON Schema, a JSON Schema validator typically focuses on the JSON Schema assertions and applicators, and will ignore most JSON Schema annotations - especially https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-9[meta-data annotations], such as "title" and "description."

======


[[jsonschema_schemaconversionrules_schemapackage]]
==== Schema Packages

[[jsonschema_schemaconversionrules_schemapackage_overview]]
===== Overview

Schema packages have the stereotype \<<applicationSchema>>, \<<schema>>, or an alias (e.g., using a specific language, like \<<anwendungsschema>>). An \<<applicationSchema>> package represents an application schema according to ISO 19109. The stereotype \<<schema>> has been introduced for packages that should be treated like application schemas, but do not contain feature types.

[[jsonschema_schemaconversionrules_schemapackage_definitions]]
===== Definitions Schema

A UML application schema and its classes SHALL be converted into one or more so-called _definitions schemas_. A definitions schema is a JSON Schema that has the "$defs" keyword.

NOTE: In the JSON Schema specification draft, version 07, the keyword of the definitions section was "definitions". In JSON Schema specification draft, version 2019-09, the keyword was changed to "$defs."

#TBD#: We can simplify the rule - and any encoder implementation - considerably, by restricting ourselves to creating a single definitions schema per application schema. Right now, we allow a split into multiple definitions schemas using tag _jsonDocument_ on subpackages. The question is: Do we want to keep this option? Are there good reasons for doing so? Reducing download size is a bit of a weak argument, in light of caching schemas, and potential cross-referencing between definitions schemas (which can complicate validation). Furthermore, not every encoder implementation should have to support splitting into subdocuments. -> ii recommends to remove splitting into multiple definitions schemas.

The "$defs" keyword SHALL have a JSON object as value, with each member representing the JSON Schema definition of a class from the application schema.

[#example_jsonschema_definitions_schema,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a definitions schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2019-09/schema",
  "$defs": {
    "Class1": {
      "type": "object",
      "properties": {
        "prop1": {"type": "string"}
      },
      "required": ["prop1"]
    },
    "Class2": {
      "type": "object",
      "properties": {
        "prop2": {"type": "number"}
      },
      "required": ["prop2"]
    }
  }
}
----

#TODO JE# - All examples should use a specific JSON Schema version. Update the examples later on.

NOTE: The current definitions schema examples in this document mostly use "definitions" instead of "$defs." The reason is that most JSON Schema validators support JSON Schema draft-07, but at the time when the examples were developed, these validators did not fully support JSON Schema 2019-09.

By default, a UML application schema is encoded as a single definitions schema. The file name of this definitions schema SHALL be chosen as follows: If tagged value _jsonDocument_ is set on the application schema package, with a value that is not blank (i.e., purely whitespace characters), then the tag value SHALL be used as the file name of the definitions schema. Otherwise, the package name SHALL be used as fallback, replacing all spaces and forward slashes with underscores, and appending '.json'. 

If tagged value _jsonDocument_ is set on a subpackage SUB of the schema package, the classes within the subpackage (as well as subpackages of SUB for which the tagged value is not set) SHALL be encoded in additional definitions schemas.

If the encoding process does not add any actual definitions to a definitions schema, then that schema SHOULD NOT be created. Reasons for no definition being added to a definitions schema are:

* The package represented by the definitions schema is empty; and/or
* No type is directly defined in the package, and subpackages with types have their own definitions schema.


<<img_json_schema_structure_uml_example>> provides an example of a UML application schema, where the tagged value is set both on the schema package itself and on one of its leaf packages. <<img_json_schema_structure>> illustrates the structure of the resulting definitions schemas.

[#img_json_schema_structure_uml_example,reftext='{figure-caption} {counter:figure-num}']
.Example of a UML application schema with tagged value jsonDocument set
image::images/uml_for_definitions_schema_example.png[align="center"]

[#img_json_schema_structure,reftext='{figure-caption} {counter:figure-num}']
.Deriving JSON Schemas from an application schema
image::images/definitions_schemas.png[align="center"]

References from types of the application schema to other types - within the same or within an external schema - SHALL be converted as references to the according definitions schemas, using the JSON Schema keyword "$ref" - see <<img_json_schema_references_between_definitions_schemas>>.

[#img_json_schema_references_between_definitions_schemas,reftext='{figure-caption} {counter:figure-num}']
.References between JSON Schemas using $ref
image::images/references_between_definitions_schemas.png[align="center"]

A link to a particular definition within a definitions schema requires the use of a JSON Pointer or an anchor in the fragment identifier of the link URL.

https://tools.ietf.org/html/rfc6901#section-6[JSON Pointer], chapter 6, explicitly states that the media type in which a JSON value is provided needs to support this kind of fragment identifier, and that this is not the case for the media type application/json. If a JSON Schema was published with this media type, then it is possible that the application ignores a fragment identifier (because the media type does not support fragment identifiers).

Definitions schemas therefore should not be published under media type application/json. Instead, a JSON Schema should be published with media type application/schema+json - which is defined by the JSON Schema specification. The media type application/schema+json supports JSON Pointers and plain names as fragment identifiers. For further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02#section-5[JSON Schema core, chapter 5].

// JSON Schema 2019-09 and 2020-12 define another media type identifier (application/schema-instance+json). The "application/schema+json" media type is defined to offer a superset of the fragment identifier syntax and semantics provided by  "application/schema-instance+json".

[[jsonschema_schemaconversionrules_schemapackage_definitions_noteoninstancevalidation]]
[NOTE]
======
The JSON Schema with which to validate a JSON document cannot be identified within that document itself. In other words, JSON Schema does not define a concept like an xsi:schemaLocation, which is typically used in an XML document to reference the applicable XML Schema(s). Instead, JSON Schema uses link headers and media type parameters to tie a JSON Schema to a JSON document (for further details, see https://tools.ietf.org/html/draft-handrews-json-schema-02[JSON Schema core], sections 11.1 and 11.2). The relationship between a JSON document and the JSON Schema for validation can also be defined explicitly by an application.
======

[[jsonschema_schemaconversionrules_schemapackage_schemaversion]]
===== JSON Schema Version

According to https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.1.1[JSON Schema core], section 8.1.1, the root schema of a JSON Schema document should contain a "$schema" keyword. The value of this keyword identifies the JSON Schema meta-schema against which the schema is valid. Typically, that is a meta-schema defined by a specific version of the JSON Schema specification.

The "$schema" keyword SHALL therefore be added to the definitions schema. Its value SHALL be one of:

* "2019-09" (the default value of the parameter) - corresponding to the schema URI "https://json-schema.org/draft/2019-09/schema"
* "draft-07" - corresponding to the schema URI "http://json-schema.org/draft-07/schema#"

#TBD# - The supported values depends on our decision about JSON Schema versions. If we were to support multiple versions, it would be good if the differences were few - fewer than between draft-07 and 2019-09. Open API 3.1.0 uses JSON Schema 2020-12. However, OGC API still primarily uses Open API 3.0.x - which uses JSON Schema 2019-09. The differences between 2019-09 and 2020-12 are few - mostly clarification of schema constructs and their behavior, based upon implementation experience. In fact, for the JSON Schema constructs used by the encoding rules defined in this specification, there are no actual differences. Furthermore, JSON Schema expressly allows combination of JSON Schema documents that comply with different JSON Schema versions. -> ii therefore recommends to support both 2019-09 and 2020-12.


[[jsonschema_schemaconversionrules_schemapackage_schemaidentifier]]
===== Schema Identifier

According to https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.2.1[JSON Schema core], section 8.2.2.1, the root schema of a JSON Schema document should contain an "$id" keyword with an absolute URI. The "$id" identifies the schema resource with its canonical URI.

NOTE: The URI is an identifier and not necessarily a resolvable URL. If the "$id" is a URL, there is no expectation that the JSON Schema can be downloaded at that URL. However, it is recommended that the URL is stable, persistent, and globally unique.

The definitions schemas derived from the application schema package SHALL each have a unique "$id."

#TBD# Not sure if we should or even can enforce a particular URI format (as would result with the mechanism we have thus far [see below]). -> ii recommends to revise the mechanism for determining the "$id" value: use a single TV _jsonId_ to define the value of "$id". Note that, according to JSON Schema 2020-12, "this URI is an identifier and not necessarily a network locator. In the case of a network-addressable URL, a schema need not be downloadable from its canonical URI." (source: https://json-schema.org/draft/2020-12/json-schema-core.html#section-8.2.1)

The value of this id MAY use the following URI template.

[source]
----
{jsonBaseUri}/{jsonDirectory}/{jsonDocument}
----

Where:

* _{jsonBaseUri}_ is either specified via tagged value _jsonBaseUri_ on the application schema package.
* [[jsonschema_schemaconversionrules_schemapackage_schemaidentifier_jsonDirectory]]_{jsonDirectory}_ is the value of the tagged value of the same name on the application schema package. If that tagged value is undefined, the value of the _xmlns_ tagged value is used. If that tagged value is also not defined, then the string _default_ is used.
* _{jsonDocument}_ is the file name of the definitions schema, which is either defined in the UML model using tagged value of the same name on a package, or automatically derived from the application schema name.

Example: With _jsonBaseUri_ = `https://example.org`, _jsonDirectory_ = `json/schemas/schemaX/1.0`, and _jsonDocument_ = `testschema.json`, the "$id" will be:
[source]
----
"$id": "https://example.org/json/schemas/schemaX/1.0/testschema.json"
----

NOTE: The "$id" of the definitions schema is not included in other examples within this chapter, because declaring an absolute, non-existent URL in these examples often prevents JSON Pointers from these examples from working when testing the examples, for instance on https://www.jsonschemavalidator.net/ (which is a useful tool for testing JSON Schema).

[[jsonschema_schemaconversionrules_types]]
==== Types

[[jsonschema_schemaconversionrules_types_mappings]]
===== External Types

Application schemas typically use types from other schemas, for example the types defined by ISO 19103 and ISO 19107. External types can be used as value types of properties, and as supertypes for types defined in the application schema that is being converted.

Whenever an external type is used, its JSON Schema definition is needed. Either an external type is implemented as one of the simple JSON value types (e.g., string - maybe with a certain format), or it is defined by a particular JSON Schema. In case of a JSON Schema, the URL of that schema needs to be known during the encoding process. If the schema is a definitions schema, then the URL needs to be augmented with a fragment identifier that includes a JSON Pointer or an anchor reference within the schema. 

How the details about the JSON Schema encoding of external types is conveyed to the encoding process is implementation specific.

#TODO JE# Provide a mapping table for basic external types here, using the map entry files from ShapeChange as a starting point. It would be benefitial to have common JSON Schema implementations for core ISO 19103, 19107 and 19108 types.


[[jsonschema_schemaconversionrules_types_classname]]
===== Class Name

[[jsonschema_schemaconversionrules_types_classname_overview]]
====== Overview

The following use cases have been identified where converting the name of a type is useful:

* Defining location independent identifiers within the definitions schema, to create simple references to schema definitions.
* Supporting type identification, thereby enabling at least some level of type inheritance checks and semantic mapping.

These use cases are documented in the following sections.


[[jsonschema_schemaconversionrules_types_classname_anchor]]
====== Location Independent Schema Identifiers

The name of a class SHALL be encoded as value of an "$anchor" member in the schema definition of the class (within the definitions schema). 

#INTERNAL NOTE# - Applies to 2019-09, not draft-07 (which uses "$id" instead of "$anchor"). This is a significant "language" change, which we can avoid by supporting only JSON Schema 2019-09 and 2020-12.

NOTE: Schema definitions that have an "$anchor" can be referenced using the plain text value of the anchor as fragment identifier, instead of using a more complex JSON Pointer.

NOTE: The "$anchor" keyword was added in JSON Schema draft 2019-09. It replaces the somewhat ambiguous use of the "$id" keyword in JSON Schema draft 07 to define plain name fragment identifiers for subschemas. For further details, see section 8.2.3 of both https://tools.ietf.org/html/draft-handrews-json-schema-02#section-8.2.3[JSON Schema draft 2019-09] and  https://tools.ietf.org/html/draft-handrews-json-schema-01#section-8.2.3[JSON Schema draft 07].

[#example_jsonschema_types_classname_anchor,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema (version 2019-09) example of location independent schema identifiers
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft/2019-09/schema",
  "$defs": {
    "TypeA": {
      "$anchor": "TypeA",
      "...": "..."
    },
    "TypeB": {
      "$anchor": "TypeB",
      "...": "..."
    }
  }
}
----

////
If the ShapeChange target parameter _jsonSchemaVersion_ (see <<jsonschema_schemaconversionrules_schemapackage_schemaversion>>) is set to "draft-07," then __rule-json-cls-name-as-anchor__ results in the creation of the "$id" keyword, instead of the "$anchor" keyword.

NOTE: JSON Schema draft 07 requires the value of "$id" to start with "\#", thus when producing a JSON Schema compliant to JSON Schema draft 07, the combination of "#" and the class name is used as value of the "$id" key.

[#example_jsonschema_types_classname_anchor_draft07,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema (draft 07) example of location independent schema identifiers
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "$id": "#TypeA",
      "...": "..."
    },
    "TypeB": {
      "$id": "#TypeB",
      "...": "..."
    }
  }
}
----
////

[[jsonschema_schemaconversionrules_types_classname_typeidentification]]
====== Type Identification

#TBD# The addition of an "entityType" member (or a member with different name, but same purpose) should probably become a separate requirements class. For actual practical uses, the requirement might span to the actual data encoding as well. I.e., while the addition of an "entityType" member enables type based validation, there would have to be additional requirements - and enforcement mechanisms - to ensure correct values (name of the class that a certain JSON object encodes and instance of). That would be hard - if not impossible - to check using JSON Schema alone. More elaborate workflows, such as conversion to RDF using JSON-LD, and then validating with SHACL and / or an ontology may be needed (for further details, see the https://docs.ogc.org/per/20-012.html#shacl_validation[UGAS-2020 ER, section "Validation of Linked Data")]). JSON-FG has its own "featureType" member (outside of "properties"), so JSON-FG compliant encodings would not actually need an additional "entityType" member - well, at least for feature types. The "entityType" member could be relevant for GeoJSON and plain JSON based encodings. -> Either we document the creation of the "entityType" member as an additional requirements class, that is independent of the requirements classes for the three JSON Schema encoding rules, or we drop it altogether. We can also move this to a "Part 2" specification (have all essential requirements classes in "Part 1", and move non-essential ones to separate parts).

If the class C that is being converted is a feature type, an object type, or a data type, then the JSON member "entityType" shall be added to the properties of the JSON object that represents the class. The "entityType" member SHALL be required and string-valued. It SHALL be used to encode the name of the type that is represented by the JSON object. However, if the JSON Schema encoding of any of the potentially existing supertypes of the class already defines the "entityType" member, then the "entityType" member SHALL NOT be added to the JSON representation of class C. 

NOTE: By default, the property value is not restricted using "const", because doing so would prevent JSON Schema constraints that support inheritance-related checks. However, if the application schema did not use inheritance, then such restrictions could be defined.

[#example_jsonschema_types_classname_typeidentification,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example with property "entityType" used for identifying the type of a JSON object
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "property": {
          "type": "string"
        }
      },
      "required": [
        "entityType", "property"
      ]
    }
  },
  "$ref": "#/definitions/Type"
}
----

The following JSON instance is valid against the schema:

[source,json,linenumbers]
----
{
  "entityType": "Type",
  "property": "x"
}
----

Encoding the type name in JSON objects can be useful.

* Encoding the type of a JSON object together with its other properties supports a more complete validation of property values, where the property type is a supertype. For further details, see <<jsonschema_schemaconversionrules_properties_valuetype>>.
* As described in http://docs.opengeospatial.org/per/18-091r2.html#JSON_LD[chapter 6 of the OGC Testbed-14: Application Schemas and JSON Technologies Engineering Report], having a key within a JSON object with a string value that identifies the type of the object allows that object to be mapped to RDF. More specifically, the string value can be mapped to an IRI that identifies the type of an RDFS resource.


[[jsonschema_schemaconversionrules_types_abstractness]]
===== Abstractness

JSON Schema does not directly support abstractness. An abstract class is therefore encoded like a non-abstract class.

NOTE: Encoding a JSON object that represents an abstract type, with the "entityType" having the abstract type name as value, would be useful with regards to linked data applications, and conversion of JSON data to RDF using JSON-LD. Abstractness is also not supported in RDF/OWL, so RDF resources can define the RDFS/OWL class or datatype, which represent an abstract type from the conceptual model, as their type. That makes sense for cases in which the exact type of a resource or "thing" is not known yet, but a more general type is.


[[jsonschema_schemaconversionrules_types_inheritance]]
===== Inheritance

[[jsonschema_schemaconversionrules_types_inheritance_overview]]
====== Overview

JSON Schema does not support the concept of inheritance itself. The following sections document the conversion of an inheritance relationship, covering the topics of <<jsonschema_schemaconversionrules_types_inheritance_generalization>> and  <<jsonschema_schemaconversionrules_types_inheritance_specialization>>. A special case of generalization, for classes with specific stereotypes, is discussed in section <<jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships>>.

[[jsonschema_schemaconversionrules_types_inheritance_generalization]]
====== Class Generalization and Property Inheritance

The generalization relationship of a subtype to its supertype is converted by combining the structural constraints of the subtype and its supertype using the JSON Schema keyword "allOf."

[#img_json_schema_inheritance_generalization_example,reftext='{figure-caption} {counter:figure-num}']
.Example of type inheritance
image::images/Generalization_example.png[align="center"]

[#example_jsonschema_types_inheritance_generalization,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example for realizing generalization using "allOf"
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "properties": {
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "TypeB": {
      "allOf": [
        {
          "$ref": "#/definitions/TypeA"
        },
        {
          "type": "object",
          "properties": {
            "propertyB": {
              "type": "string"
            }
          },
          "required": [
            "propertyB"
          ]
        }
      ]
    }
  },
  "$ref": "#/definitions/TypeB"
}
----

This JSON object is valid against the schema from <<example_jsonschema_types_inheritance_generalization>>:

[source,json,linenumbers]
----
{
  "propertyA": 2,
  "propertyB": "x"
}
----

This JSON object is invalid (because "propertyA" is missing) against the schema from <<example_jsonschema_types_inheritance_generalization>>:

[source,json,linenumbers]
----
{
  "propertyB": "x"
}
----

NOTE: This also works for an encoding where the properties of a class are nested within a key-value pair (like "properties" for a GeoJSON encoding).

NOTE: The case where a property from a supertype is redefined by a property from the subtype is supported. Redefinition in UML requires that the value type of the subtype property is "kind of" the type of the redefined property of the supertype. Therefore, the property value, when encoded in JSON, would satisfy the JSON Schema constraints defined by both the subtype property and the redefined supertype property.

This approach to converting a generalization relationship has the following restrictions.

* The JSON Schema keyword "additionalProperties" must not be set to false in the definitions of both the super- and the subtype.
* The approach only works for generalization relationships of feature, object, and data types. For unions, enumerations, and code lists generalization relationships are not supported.
* It only converts the generalization relationship from subtype to supertype. It does not support the other direction of an inheritance relationship, i.e., specialization. Given a JSON object that encodes a subtype, and the JSON Schema of the supertype, then only the constraints of the supertype are checked, but not all the constraints that apply to the subtype. That is an issue when encoding a UML property whose value type is or could be a supertype (via a subtype that is added by an external, so far unknown schema). Conceptually, the actual value of that property can be a supertype object, but it could just as well be an object whose type is a subtype of that supertype. This issue can only be solved to a certain degree with JSON Schema, as explained in the <<jsonschema_schemaconversionrules_types_inheritance_specialization>> section.

Multiple inheritance is supported by adding all supertypes as elements of "allOf."

[[jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships]]
====== Virtual Generalization

#TBD# This is primarily applicable to GeoJSON-based encoding rules, i.e. the GeoJSON and JSON-FG encoding rules. Both GeoJSON and JSON-FG define their own JSON Schema for features. -> ii recommendation: requirements defining a common base schema should only be defined for GeoJSON and JSON-FG, and only for \<<featureType>>s ... though maybe also for object types?

It is often useful to encode all classes with a certain stereotype with a common base type. The generalization relationship to such a base type is often implied with the stereotype, for a given encoding. In GML, for example, the common base type for classes with stereotype \<<featureType>> is gml:AbstractFeature. Rather than explicitly modeling such a base type (e.g., _AnyFeature_ defined by ISO 19109), as well as explicitly modeling generalization relationships to the base type, the encoding rule typically takes care of adding that relationship to relevant schema types.

For the GeoJSON encoding rule, all feature and object types SHALL use the GeoJSON Feature (https://geojson.org/schema/Feature.json) definition as common base.

The virtual generalization relationship is implemented by converting the class to a JSON Schema that consists of an "allOf" with two subschemas: the first being a "$ref" with the URI of the common base, the second being the schema produced by applying the other conversion rules to the class. However, if one of the supertypes of the class already has the common base in its definition, then the class itself shall not define it again.

If the class is encoded with an "allOf" for the common base, then the "$anchor" member (see <<jsonschema_schemaconversionrules_types_classname_anchor>>) SHALL be encoded in the schema that contains the "allOf", instead of within the second subschema.


[[jsonschema_schemaconversionrules_types_inheritance_specialization]]
====== Class Specialization and Property Ranges

// implementation status: not implemented - on hold until actual need for this kind of validation is expressed by OGC community

By default, JSON Schema based validation of a JSON encoded property value, with the value having a complex type (i.e., being a JSON object or an array of JSON objects), only encompasses checking the JSON Schema constraints defined for that type. If the property value actually is a subtype of that type, then the constraints defined for that subtype are not checked. Ideally, the constraints of known and unknown subtypes would automatically be checked, but JSON Schema does not support this.

NOTE: If JSON data was transformed to RDF using JSON-LD, then class specialization and property ranges could fully be checked by validating the RDF data using SHACL. 

#TBD# All of the following would go too far. -> ii recommendation: stop here and simply refer to the UGAS-2020 ER (i.e., remove the following NOTE and refer to the UGAS-2020 ER, for more details about a potential conversion approach)

To a limited extent, specialization relationships could be represented in JSON Schema, but only for subtypes in the same schema/model and using complex, verbose constructs from JSON Schema. This would make the schemas hard to read (by humans) and to parse (by application schema parsers in clients). The value of such a capability is therefore questionable and currently not supported.

[NOTE]
====
A potential conversion rule would look as follows:

The conversion rule would support known subtypes. "Known" are the subtypes defined in the UML model that contains the application schema from which the JSON Schema is derived.

There would be a limitation that subtypes from different schemas with identical class names, but conflicting definitions (e.g., `SchemaA::ExtensionX.propA` has type `string`, while `SchemaB::ExtensionX.propA` has type `number`) are not supported.

A pre-condition of the conversion rule would be that the subtype name must be included in the encoding of the JSON object. The conversion rule therefore would require the presence of the "entityType" member (see section <<jsonschema_schemaconversionrules_types_classname_typeidentification>>).

The definitions schema includes a definition for each type that is being converted. Under the additional conversion rule for specialization, a second definition would be generated for each supertype of the application schema (that is a feature, object, or data type). The name of that definition would be constructed as: `{type-name}_valueType`. That name would also be encoded as "$anchor" of the new definition.

The JSON Schema of the new definition would be constructed as follows.

* Determine the list of direct and indirect subtypes. If abstract types are also converted (see <<jsonschema_schemaconversionrules_types_abstractness>>), then abstract subtypes would be included, too.
* Create a sequence of if-then-else expressions, where the if-condition checks the "entityType" against the name of a subtype, the "then" case refers to the JSON Schema definition of that type, and the "else" case represents the if-then-else for the next subtype. The last "else" case refers to the JSON Schema definition of the supertype. <<example_jsonschema_types_inheritance_specialization>> illustrates how this would look like, for the UML model from <<img_jsonschema_valuetype_uml>>.

The resulting JSON Schema looks for an "entityType" match. If one is found, the JSON object is validated against the JSON Schema definition of that type. If no match is found, then the JSON Schema of the supertype is used as a fallback for validation. The JSON object would then at least have to fulfill the constraints defined by the schema of the supertype. However, any additional content of the JSON object would not be validated.

[#img_jsonschema_valuetype_uml,reftext='{figure-caption} {counter:figure-num}']
.Example of a value type being a supertype
image::images/Specialization_example.png[align="center"]

[#example_jsonschema_types_inheritance_specialization,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a value type definition for a supertype
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "entityType",
        "propertyA"
      ]
    },
    "TypeA_valueType": {
      "if": {
        "properties": {
          "entityType": {
            "const": "TypeB"
          }
        }
      },
      "then": {
        "$ref": "#/definitions/TypeB"
      },
      "else": {
        "$ref": "#/definitions/TypeA"
      }
    },
    "TypeB": {
      "allOf": [
        {
          "$ref": "#/definitions/TypeA"
        },
        {
          "type": "object",
          "properties": {
            "entityType": {
              "type": "string"
            },
            "propertyB": {
              "type": "string"
            }
          },
          "required": [
            "entityType",
            "propertyB"
          ]
        }
      ]
    },
    "TypeC": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "propertyC": {
          "$ref": "#/definitions/TypeA_valueType"
        }
      },
      "required": [
        "entityType",
        "propertyC"
      ]
    }
  },
  "$ref": "#/definitions/TypeC"
}
----

The following two JSON objects are valid against the schema from <<example_jsonschema_types_inheritance_specialization>>:

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "TypeA",
    "propertyA": 3
  }
}
----

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "TypeB",
    "propertyA": 3,
    "propertyB": "x"
  }
}
----

The next JSON object is also valid against the schema from <<example_jsonschema_types_inheritance_specialization>>, because the value of "propertyC" matches the schema of supertype TypeA, even though the entity type is unknown:

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "UnknownExtensionTypeA",
    "propertyA": 3
  }
}
----

The following two JSON objects are invalid against the schema from <<example_jsonschema_types_inheritance_specialization>> (in both cases because the type of "propertyA" is string instead of number):

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "TypeB",
    "propertyA": "y",
    "propertyB": "x"
  }
}
----

[source,json,linenumbers]
----
{
  "entityType": "TypeC",
  "propertyC": {
    "entityType": "UnknownExtensionTypeB",
    "propertyA": "z"
  }
}
----

Note that if the last else-case simply was 'false', then that would prevent any unknown subtype from being encoded - at least with the value type definition created and used within the definitions schema that is being produced. For a non-abstract supertype, the if-then-else construct would then have to contain an additional `if (entityType=Supertype) then $ref: schemaSupertype` - before the case of "else false."

====

[[jsonschema_schemaconversionrules_types_featureandobjecttype]]
===== Feature and Object Type

[[jsonschema_schemaconversionrules_types_featureandobjecttype_overview]]
====== Overview

In the conceptual model, feature and object types represent objects that have identity. That differentiates these types from, for example, data types. Other than that, feature and object types are encoded as JSON objects, just like a data type.

A feature or object type - in the following summarily called types with identity - is converted to a JSON Schema definition which is added to the definitions schema, using the type name as definition key. Note that ISO 19109 requires class names to be unique within the scope of an application schema.

The conversion of the class properties is defined in the <<jsonschema_schemaconversionrules_properties>> section. General type conversion rules, such as those documented in the <<jsonschema_schemaconversionrules_types_classname>> section, may apply. Additional conversion rules and behavior for types with identity are described in the following sections.

[[jsonschema_schemaconversionrules_types_featureandobjecttype_identifier]]
====== Identifier

#TBD# - The stereotype \<<identifier>> is not defined by any of the ISO standards. However, we should introduce it for requirements of GeoJSON-based encoding rules, which need a way to identify and omit identifier properties. The purpose of the omission would be that the "id" member within the GeoJSON or JSON-FG feature schema should be used instead. The requirement would assume that \<<identifier>> properties are located within the direct properties of a type with identity (feature or object type). If that is not the case for a conceptual schema, the schema would need to be transformed, in order to achieve a suitable implementation schema, on which the UML2JSON encoding rules can be applied. ... A similar approach should be taken for determining the geometric properties to be used in the GeoJSON "geometry" member as well as in the JSON-FG "place" member - and also the JSON-FG "time" member (requiring the identification of temporal properties). Note that for the plain JSON encoding, an \<<identifier>> property would be encoded as-is; no specific requirement would apply to it. Also, if the application schema does not define \<<identifier>> properties for types with identity, then in the plain JSON encoding, these objects would not have a member to store any identifier, and identification would have to be achieved via an external means. For the GeoJSON and JSON-FG encoding rules, the "id" member can still be used to encode an identifier property. In any case, we would not provide a means to generate an identifier property, as was defined and implemented in UGAS-2020. Application schemas that shall be encoded as plain JSON may have to explicitly model an identifier property.

The conceptual model of a type with identity often does not contain a property whose value is used by applications to identify objects of that type. Instead, the according information is added or defined in platform specific encodings. For example, a GML application schema offers the gml:id attribute as well as the gml:identifier element to encode identifying information.

In a web publishing context, the URI at which a JSON object is published can be used as its identifier. Therefore, the default behavior of the ShapeChange JSON Schema target is to not add an identifier property. However, in many applications it is useful to have a member within a JSON object that provides the identifier of that object. Existing specifications often include such a capability, e.g., the "id" member in GeoJSON or "@id" in JSON-LD.

With __rule-json-cls-identifierForTypeWithIdentity__, an identifier JSON member will be added to the JSON object that represents the type with identity. The key, and value type of that member can be configured using ShapeChange JSON Schema target parameters:

* __objectIdentifierName__: "id" (the default) or any other suitable string that does not conflict with other member names);
* __objectIdentifierType__: "string" (the default), "number", or "string, number";

// "string, number" because GeoJSON does it that way

* __objectIdentifierRequired__: "false" (the default) or "true" is used to define if the property is required or optional.

[#example_jsonschema_types_featureandobjecttype_identifier,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a feature type with a required identifier property "id"
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeA": {
      "properties": {
        "entityType": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "propertyA": {
          "type": "number"
        }
      },
      "required": [
        "entityType",
        "id",
        "propertyA"
      ]
    }
  },
  "$ref": "#/definitions/TypeA"
}
----

The following JSON object is valid against the schema from <<example_jsonschema_types_featureandobjecttype_identifier>>:

[source,json,linenumbers]
----
{
  "entityType": "TypeA",
  "id": "42445fdasd7asd6f7",
  "propertyA": 3
}
----

__rule-json-cls-identifierForTypeWithIdentity__ is ignored if one of the following conversion rules is part of the encoding rule as well:

* __rule-json-cls-identifierStereotype__ - This conversion rule assumes that all types with identity have an attribute with stereotype \<<identifier>> (directly, or inherited from a supertype). That attribute is used to encode the identifier. +
+
NOTE: If the maximum multiplicity of an \<<identifier>> attribute is greater than 1, ShapeChange will log an error.

* __rule-json-cls-ignoreIdentifier__ - With this rule, the identifier of a type with identity will be encoded using an identifier member that is provided by a common base type (e.g., the "id" member of a GeoJSON Feature, to which a generalization relationship exists for a given feature type - see <<jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships>>). That means that no additional identifier property is created. __rule-json-cls-identifierForTypeWithIdentity__ is therefore overridden by __rule-json-cls-ignoreIdentifier__. Also, all identifier properties that are identified by __rule-json-cls-identifierStereotype__ - if also included in the encoding rule - will simply be ignored when encoding the type with identity.

To prevent the addition of unnecessary JSON members (here: because the JSON member would already be inherited), __rule-json-cls-identifierForTypeWithIdentity__ is ignored for a type T if T is a subtype and __rule-json-cls-identifierForTypeWithIdentity__ already applies to one of its supertypes.


[[jsonschema_schemaconversionrules_types_featureandobjecttype_nestedproperties]]
====== Nested Properties

#TBD# Make this a requirement to be included by the requirements classes of all GeoJSON-based encoding rules. There can be a common "AbstractGeoJSON" requirements class that extends core and would itself be extended by actual requirements classes fo the GeoJSON-based encoding rules, i.e. GeoJSON and JSON-FG. Also, the requirement should apply to feature and potentially also object types (depending upon whether object types receive the same common base type as feature types; see TBD in <<jsonschema_schemaconversionrules_types_inheritance_virtualgeneralizationrelationships>>).

By default, the properties of a type are converted to first-level properties of the resulting JSON object. In the GeoJSON encoding rule, properties of a type with identity shall be encoded within the GeoJSON "properties" member, i.e. within a nested "properties" member. Notable exceptions from that rule are the GeoJSON members "id," "geometry," and "bbox."

NOTE: <<example_jsonschema_encrule_geojson>> illustrates the result of applying this requirement, given the feature type in <<img_jsonschema_encrule_geojson_uml>>.


[[jsonschema_schemaconversionrules_types_datatype]]
===== Data Type

A \<<dataType>> is converted to the JSON Schema definition of a JSON object. The properties of the data type are converted to the properties of that object, as described in the <<jsonschema_schemaconversionrules_properties>> section.


[[jsonschema_schemaconversionrules_types_union]]
===== Union

[[jsonschema_schemaconversionrules_types_union_overview]]
====== Overview

Application schemas have two ways of using types with stereotype \<<union>>.

* According to ISO 19103:2015, a \<<union>> type consists __"of one and only one of several alternative datatypes (listed as member attributes). This is similar to a discriminated union in many programming languages"__. According to this definition, only the types of the UML attributes defined for a \<<union>> are of interest.
* In practice, unions defined in application schemas can also have another use: they define a choice between a number of options, where each option is defined by a UML attribute. In other words, the attribute itself has meaning (not just its value type). Multiple options can have the same value type. Options can have different maximum multiplicity (especially greater than 1). The UML-to-GML application schema encoding rules support this way of using unions (see OGC 07-036r1, section E.2.4.10).

The following sections document the conversion rules that support these two approaches of using unions.

#TBD# - The UGAS-2020 ER has two conversion rules for unions - depending upon the way that unions are intended to be used in specific application schemas. In general, there are two patterns - see above. In the INSPIRE consolidated UML model, themes, annex III, we can find two examples of unions that are intended to be used as property choices: Age and AreaOfResponsibilityType. An example of a type discriminator union in the INSPIRE schemas is DayOrDate (there are others from OGC and ISO schemas, such as AnyNumerical and LBS_GeometryChoice). We need to discuss if we want to support both types of union usage in the JSON Schema conversion rules (one could say that the "property choice" conversion is all-encompassing, but then again, not everyone who is just using type discriminator unions may be happy with that restriction, and prefer to have the "type discriminator" conversion at their disposal). If we do want to support both types of union conversions, then they must become separate requirements classes. Communities can then pull them in for their JSON Schema encoding, as needed, together with the JSON Schema encoding rule of their choice. So, for example, community A can use the plain JSON encoding rule together with the type discriminator conversion for its unions, while community B can use the GeoJSON encoding rule with the property choice conversion of unions. Since the \<<union>> stereotype is not used in all application schemas, an approach for dealing with the situation in which we want to support both conversions of unions would be to create an additional specification, a "part 2", of the UML-to-JSON encoding rules. In that part 2, we could specify additional conversion rules, such as for \<<union>> types, which are not essential for converting an application schema to JSON Schema. For cases in which an application schema does contain a \<<union>>, then part 1 AND part 2 would be used. For \<<codelist>> types, the situation is similar (we have more than one encoding option).


[[jsonschema_schemaconversionrules_types_union_propertychoice]]
====== Property Choice

A \<<union>> SHALL be converted to the JSON Schema definition of a JSON object. Each union option SHALL be represented as an optional member of the JSON object. The choice between the options defined by the union SHALL be encoded using "maxProperties" = "minProperties" = 1. That is, the number of members that are allowed for the JSON object is restricted to exactly one.

An `"additionalProperties": false` SHALL be used to prevent any undefined properties. The result of applying these rules to the union from <<img_jsonschema_union_example>> is shown in <<example_jsonschema_union_minMaxProperties>>.

[#img_jsonschema_union_example,reftext='{figure-caption} {counter:figure-num}']
.\<<union>> example
image::images/Union_example.png[align="center"]

[#example_jsonschema_union_minMaxProperties,reftext='{listing-caption} {counter:listing-num}']
.Example of a JSON Schema for a \<<union>> class, representing the property choice using "minProperties" and "maxProperites"
[source,json, linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "UnionA": {
      "type": "object",
      "properties": {
        "option1": {
          "type": "string"
        },
        "option2": {
          "type": "number"
        }
      },
      "additionalProperties": false,
      "minProperties": 1,
      "maxProperties": 1
    }
  },
  "$ref": "#/definitions/UnionA"
}
----

NOTE: An alternative approach would be using the "oneOf" keyword, with one subschema per union property, which only defines that property, and requires it (but does not perform any other checks). This option is more verbose, harder to read and understand and, therefore, not recommended.

This JSON object is valid against the schema from <<example_jsonschema_union_minMaxProperties>>:

[source,json,linenumbers]
----
{
  "option1": "x"
}
----

This JSON object is invalid (because "option2" has a string value, rather than a numeric value) against the schema from <<example_jsonschema_union_minMaxProperties>>:

[source,json,linenumbers]
----
{
  "option2": "x"
}
----

[[jsonschema_schemaconversionrules_types_union_typediscriminator]]
====== Type Discriminator

The \<<union>> is converted to a JSON Schema definition that represents a choice between the value types of the union properties.

* If the value types are only simple, without a specific format definition or other restrictions defined by JSON Schema keywords, then the JSON Schema will only contain a "type" member, with an array of the simple types.
* Otherwise, a "oneOf" member is added to the JSON Schema definition, with:
** one "$ref" per non-simple type,
** one "type" for all simple types without specific keywords, and
** one "type" per simple type with specific keywords.

The result of applying the rule to the union from <<img_jsonschema_type_discriminator_union_example>> is shown in <<example_jsonschema_union_minMaxProperties>>.

[#img_jsonschema_type_discriminator_union_example,reftext='{figure-caption} {counter:figure-num}']
.Example of type discriminator unions
image::images/type_discriminator_unions.png[align="center"]

[#example_jsonschema_union_type_discriminator,reftext='{listing-caption} {counter:listing-num}']
.Example of a JSON Schema for unions, encoding them as type discriminators
[source,json, linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Union_TypeDiscriminator": {
      "oneOf": [
        {
          "type": [
            "string",
            "integer"
          ]
        },
        {
          "$ref": "https://geojson.org/schema/Point.json"
        },
        {
          "type": "string",
          "format": "date"
        }
      ]
    },
    "Union_TypeDiscriminator_OtherTypes": {
      "oneOf": [
        {
          "$ref": "https://geojson.org/schema/LineString.json"
        },
        {
          "$ref": "https://geojson.org/schema/Point.json"
        }
      ]
    },
    "Union_TypeDiscriminator_SimpleTypes": {
      "type": [
        "string",
        "integer"
      ]
    }
  }
}
----

[[jsonschema_schemaconversionrules_types_enumeration]]
===== Enumeration

An \<<enumeration>> SHALL be converted to a JSON Schema definition with a type defined by evaluating tagged value _literalEncodingType_. In addition, it SHALL use the "enum" keyword to restrict the value to one of the enums from the enumeration.

The tagged value _literalEncodingType_ identifies the conceptual type that applies to the enumeration values. If the tagged value is not set on the enumeration, or has an empty value, then the literal encoding type is defined to be CharacterString. The literal encoding type is one of the types from ISO 19103, which are implemented as a simple JSON Schema type:

[#table_literalencodingtypes,reftext='{table-caption} {counter:table-num}']
.Literal encoding type
[options="header"]
|====================
| Conceptual type from ISO 19103 | simple JSON Schema type
| CharacterString | string
| Boolean | boolean
| Real, Number | number
| Integer | integer
|====================

The enumeration values will be encoded accordingly.

[#img_jsonschema_enumeration_example,reftext='{figure-caption} {counter:figure-num}']
.\<<enumeration>> example
image::images/Enumeration_example.png[align="center"]

[#example_jsonschema_enumeration,reftext='{listing-caption} {counter:listing-num}']
.Example of enumerations encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Enumeration1": {
      "type": "number",
      "enum": [-5, 0, 5.5]
    },
    "Enumeration2": {
      "type": "string",
      "enum": ["A","B","C"]
    }
  },
  "anyOf": [
    {"$ref": "#/definitions/Enumeration1"},
    {"$ref": "#/definitions/Enumeration2"}
  ]
}
----

[[jsonschema_schemaconversionrules_types_codelist]]
===== Code List

#TBD# The situation for code lists is similar to that of unions. We have multiple conversion behaviors for converting attributes with a code list value type: the type is either a simple type (e.g. string or number), a URI, or a link object.

By default, a \<<codelist>> is converted to a JSON Schema definition with a type defined by evaluating tagged value _literalEncodingType_.

The tagged value _literalEncodingType_ identifies the conceptual type that applies to the code values. If the tagged value is not set on the code list, or has an empty value, then the literal encoding type is defined to be CharacterString. The literal encoding types are as defined in <<table_literalencodingtypes>>.

With __rule-json-cls-codelist-uri-format__, all code lists will be represented by a JSON Schema that restricts the type to "string", and states that the "format" is "uri" (as defined by https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7.3.5[JSON Schema validation, section 7.3.5]).

With __rule-json-cls-codelist-link__, all code lists will be represented by a JSON Schema that restricts the type to a http://schemas.opengis.net/ogcapi/features/part1/1.0/openapi/schemas/link.yaml["Link" object] as specified by IETF RFC 8288 and implemented in the OGC API standards. The Link object provides "href" and "title" members like the simple Xlinks in GML.

NOTE: The URL to the JSON Schema of the "Link" object (as shown in <<example_jsonschema_link_object>>) can be configured using the ShapeChange JSON Schema target parameter _linkObjectUri_.

[#example_jsonschema_link_object,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema of the "Link" object
[source,json,linenumbers]
----
include::code/link.json[]
----

In <<img_jsonschema_codelist_example>>, the encoding rule for code list "CodelistLinkObject" contains __rule-json-cls-codelist-link__, whereas the encoding rule for code list "CodelistUriFormat" contains __rule-json-cls-codelist-uri-format__, and the encoding rule for the remaining two code lists contains none of these conversion rules. The resulting JSON Schema is shown in <<example_jsonschema_codelist>>.

[#img_jsonschema_codelist_example,reftext='{figure-caption} {counter:figure-num}']
.\<<codeList>> example
image::images/Codelist_example.png[align="center"]

[#example_jsonschema_codelist,reftext='{listing-caption} {counter:listing-num}']
.Example of code lists encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "CodelistLinkObject": {
      "$ref": "http://example.org/jsonschema/link.json"
    },
    "CodelistNumeric": {
      "type": "number"
    },
    "CodelistString": {
      "type": "string"
    },
    "CodelistUriFormat": {
      "type": "string",
      "format": "uri"
    }
  }
}
----

NOTE: A string based code list conversion is better suited for a subsequent mapping of JSON encoded code values to RDF using JSON-LD. 


[[jsonschema_schemaconversionrules_types_basictype]]
===== Basic Type

#TBD# Not sure if we actually need to support basic types. Is that something that occurs in application schemas that need to be encoded by Geonovum?

If a direct or indirect supertype of an application schema class is represented in JSON Schema by one of the simple JSON Schema types _string_, _number_, _integer_, or _boolean_, then that class represents a so called _basic type_.

A basic type does not define a JSON object. It represents a simple data value, e.g., a string. The JSON Schema definition of a basic type thus defines a simple JSON Schema type. A basic type can be restricted using a number of JSON Schema keywords. <<table_basictypes_restrictions>> defines which tagged values can be used to define these restrictions for a basic type, and which restrictions are available for which simple JSON Schema type.

[#table_basictypes_restrictions,reftext='{table-caption} {counter:table-num}']
.Basic type restrictions
[options="header"]
|====================
| JSON Schema keyword | tagged value to define the restriction | applicable JSON Schema type(s)
| format | _jsonFormat_ | string, number, integer
| maxLength | _length_, _maxLength_, or _size_ | string
| pattern | _jsonPattern_ | string
| minimum +
(inclusive) | _rangeMinimum_ | number, integer
| maximum +
(inclusive) | _rangeMaximum_ | number, integer
|====================

NOTE: The JSON Schema keyword "format" is defined in chapter 7 of <<ref_jsonschema_02_validation,JSON Schema Validation: A Vocabulary for Structural Validation of JSON>>. The formats defined there (e.g., "date-time", "uri", and "json-pointer") apply to JSON values of type string. Custom formats could apply to JSON values of type number and integer.

NOTE: <<ref_jsonschema_02_validation,JSON Schema Validation: A Vocabulary for Structural Validation of JSON>> defines the JSON Schema keyword "pattern". According to that specification, the value of the keyword should be a regular expression according to the ECMA 262 regular expression dialect. However, the specification does not reference a particular version or edition of ECMA 262. The regular expression dialect to be used in a JSON Schema "pattern" therefore is not exactly defined, and consequently depends on the implementation of a JSON Schema validator. In order to avoid issues with this diversity, <<ref_jsonschema_02,JSON Schema: A Media Type for Describing JSON Documents>> defines a number of recommendations for writing regular expressions in JSON Schema.

NOTE: If the "format" keyword is used to restrict the structure of a JSON string, so that it matches a certain regular expression, then it is useful to add the "pattern" keyword as well, explicitly defining that regular expression (given that the regular expression follows an ECMA 262 regular expression dialect). The reason is that the "format" is first and foremost an annotation, so can be ignored by JSON Schema validators, whereas the "pattern" keyword will be evaluated by a JSON Schema validator. JSON Schema validators may treat the "format" keyword like an assertion, but that is not guaranteed. In any case, the "format" keyword helps to convey more information about the specific type of a JSON value (e.g., "date" instead of just "string"), and thus should not be omitted if a certain, well-known (i.e., defined by a JSON Schema vocabulary) format is applicable to a JSON value.

There are a number of cases which need to be considered when encoding a basic type.

* The basic type directly inherits from a type that is represented by one of the simple JSON Schema types listed above: in that case, the JSON Schema definition of the basic type will include the "type" keyword with appropriate value, and potentially also the "format" keyword if the supertype is encoded in JSON with a specific format. In addition, restrictions defined for the basic type via tagged values are encoded using the appropriate JSON Schema keywords (as defined in <<table_basictypes_restrictions>>).
* Otherwise, i.e., the basic type does not directly inherit from a type that is mapped to a simple JSON Schema type:
** If no restrictions are defined for the basic type, then the JSON Schema definition of the basic type simply contains a "$ref" to the JSON Schema definition of the direct supertype.
** Otherwise, i.e., restricitons are defined, an "allOf" is used to refer to the JSON Schema definition of the direct supertype, and to define a JSON Schema with the restrictions that apply to the basic type.

<<img_jsonschema_basictypes_example>> provides a detailed example that illustrates these cases. The JSON Schema encoding is shown in <<example_jsonschema_basictypes>>.

[#img_jsonschema_basictypes_example,reftext='{figure-caption} {counter:figure-num}']
.Basic types example
image::images/basic_types_example.png[align="center"]

[#example_jsonschema_basictypes,reftext='{listing-caption} {counter:listing-num}']
.Example of basic types encoded in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "MyBoolean": {
      "type": "boolean"
    },
    "MyCharacterString": {
      "type": "string"
    },
    "MyNumber": {
      "type": "number"
    },
    "Number0to360": {
      "allOf": [
        {
          "$ref": "#/definitions/NumberNonNegative"
        },
        {
          "maximum": 360.0
        }
      ]
    },
    "NumberMinus180toPlus180": {
      "allOf": [
        {
          "$ref": "#/definitions/MyNumber"
        },
        {
          "minimum": -180.0,
          "maximum": 180.0
        }
      ]
    },
    "NumberNonNegative": {
      "allOf": [
        {
          "$ref": "#/definitions/NumberOther"
        },
        {
          "minimum": 0.0
        }
      ]
    },
    "NumberOther": {
      "$ref": "#/definitions/MyNumber"
    },
    "String10": {
      "allOf": [
        {
          "type": "string"
        },
        {
          "maxLength": 10
        }
      ]
    },
    "StringFormat": {
      "allOf": [
        {
          "$ref": "#/definitions/MyCharacterString"
        },
        {
          "format": "email"
        }
      ]
    },
    "StringPattern": {
      "allOf": [
        {
          "$ref": "#/definitions/MyCharacterString"
        },
        {
          "pattern": "^[abc]{3}$"
        }
      ]
    }
  }
}
----

[[jsonschema_schemaconversionrules_types_defaultgeometry]]
===== Default Geometry

#TBD# This concerns the GeoJSON as well as the JSON-FG encoding rules. What we need is one requirement for populating the GeoJSON "geometry" feature member, and on top of that, for the JSON-FG encoding rule, one requirement that defines how the "place" member of a JSON-FG feature is populated (primary use case would be 3D geometries, which are not supported by GeoJSON). Furthermore, for JSON-FG, we also need to define how the "time" member shall be populated / encoded. The requirements would define which of the UML attributes would be mapped to which pre-defined GeoJSON / JSON-FG feature member.

By default, any property with a geometry type is converted as any other property, with the geometry type being represented with the appropriate JSON Schema encoding (see section <<jsonschema_schemaconversionrules_types_mappings>>).

This may not always be desired. A GeoJSON Feature, for example, has a dedicated (and required) member - "geometry" - for encoding the feature geometry. Geometry properties defined within an application schema may therefore need to be mapped to this "geometry" member. Additional conversion behavior is required to define and achieve this mapping.

#TODO JE# Merge the two cases, assuming that multiple geometry properties can occur, look for defaultGeometry TV - and if there is only a single geometry property, use it as the default geometry.

Two kinds of application schemas need to be distinguished:

. application schemas where a class has at most one geometry property, typically a property with one of the ISO 19107 geometry types as value type; and
. application schemas where classes can have more than one geometry property.

NOTE: When counting geometry properties per class, inheritance also needs to be considered. A class that, through inheritance, has multiple geometry typed properties with different name belongs to an application schema of the second category, whereas a class that only has at most one geometry typed property - also through inheritance - belongs to the first category.

Two conversion rules are available to support the two kinds of application schemas.

* __rule-json-cls-defaultGeometry-singleGeometryProperty__ - for application schemas with classes that have at most one geometry property. With this rule, the geometry property of a class represents the default geometry, and is encoded as the top-level "geometry" member. If a class has multiple - potentially inherited - geometry properties with different names, none of them is selected as default geometry (because no informed choice can be made) and ShapeChange will log an error.
* __rule-json-cls-defaultGeometry-multipleGeometryProperties__ - for application schemas with classes that can have multiple geometry properties. With this rule, a geometry property is identified as default geometry by setting tagged value _defaultGeometry_ on the property to the value `true`. That property will then be encoded as a top-level "geometry" member. If multiple such properties exist (potentially inherited), none of them is selected as default geometry (because no informed choice can be made) and an error will be logged.
+
NOTE: For a class that has multiple geometry properties with different names, all such properties except the one identified as default geometry are encoded just as any other property of the class. A different behavior would be to omit these other geometry properties altogether when deriving the JSON Schema. It is unclear at this point if that would really be useful behavior. After all, the modeling expert that designed the application schema with classes that have multiple geometry properties must have had good reasons for doing so, and must also be aware that in order to perform spatial computations on the different geometry properties, special software will be required.

If a UML property is identified as default geometry, then it is implemented via the top-level "geometry" member (and not as another member of the JSON object). The "geometry" member is constrained to the JSON Schema definition to which the value type of the default geometry property is mapped.

NOTE: The schema should only use geometry types that are mapped in the configuration of the ShapeChange process. For example, in the case of a GeoJSON encoding rule, all geometry types should be mapped to GeoJSON geometry types. Otherwise the JSON Schema constraints of the GeoJSON Feature schema could not be satisfied.

NOTE: One might think that it is beneficial to set the "geometry" member to just `null` if the type that is being converted does not have a default geometry. However, that must not be done in any schema conversion, because then a default geometry defined by a super- or (maybe defined in an external schema) subtype of that type could never be mapped to the "geometry" member. The only exception would be classes marked as "final," where none of the supertypes define a default geometry.

NOTE: If the default geometry property has a maximum multiplicity greater than 1, then ShapeChange will log a warning and assume a maximum multiplicity of exactly 1.

NOTE: <<example_jsonschema_encrule_geojson>> illustrates the result of applying __rule-json-cls-defaultGeometry-singleGeometryProperty__, given the feature type in <<img_jsonschema_encrule_geojson_uml>>.

NOTE: Additional geometry properties are encoded like all other UML properties (in the GeoJSON case within the GeoJSON "properties" member).

NOTE: In some application schemas, the geometry of a feature type is not defined directly, i.e., not via a property that has an ISO 19107 type as value type. For example, consider REF img_jsonschema_value_type_options_example, where property "place" indirectly defines the geometry of a feature type, through a complex _PlaceSpecification_. The place is either given by a point, a curve, a surface, or by some location identifier. Such a feature model, where the geometry of a feature can be one of several geometry and non-geometry types, is not suited for the conversion rules documented in this section.


[[jsonschema_schemaconversionrules_properties]]
==== Properties

A UML property of a class is converted to a member of a JSON object - unless the encoding rule defines a different behavior for the type that owns the property (e.g., for enumerations and code lists).

#TODO JE# Note that by default, UML properties are converted to keys within the "properties" member of the JSON Schema definition for the type that owns the property (see below). Also note that additional requirements may override this encoding (e.g. type discriminator encoding of \<<union>> properties), or augment the encoding (e.g. encoding the properties under the "properties" member of a GeoJSON-based feature).

The default result of converting a UML property, therefore, is a key within the "properties" key of the JSON Schema definition for the type that owns the property, with the key name being the name of the UML property, and the value being a JSON Schema with constraints and annotations that define the property (value type, multiplicity, etc).

The following figure and listing provide an example: <<img_jsonschema_properties_example>> shows a feature type with a number of properties. <<example_jsonschema_properties_general>> illustrates how the UML properties are represented within the "properties" of the JSON Schema that defines that type.

[#img_jsonschema_properties_example,reftext='{figure-caption} {counter:figure-num}']
.UML type used to exemplify JSON Schema encoding of UML properties
image::images/Properties_example.png[align="center"]

[#example_jsonschema_properties_general,reftext='{listing-caption} {counter:listing-num}']
.Encoding UML properties in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeX": {
      "type": "object",
      "properties": {
        "property1": { ... },
        "property2": { ... },
        ...
      }
    }
  },
  "$ref": "#/definitions/TypeX"
}
----

[[jsonschema_schemaconversionrules_properties_valuetype]]
===== Value Type

The value type of a UML property SHALL be encoded as a JSON Schema constraint, as follows:

* If the value type of a UML property is an external type, and the JSON Schema definition of that external type is a simple JSON value type, i.e., "string", "number", "integer", or "boolean", then a "type" key is added to the JSON Schema definition of the property, with the simple JSON value type as value;
* Otherwise, a "$ref" key is added to the JSON Schema that constrains the property. The "$ref" value is a reference to the JSON Schema definition of the value type, within a particular definitions schema. The reference uses the identifier of that schema (see <<jsonschema_schemaconversionrules_schemapackage_schemaidentifier>>) as a basis, and adds a fragment identifier to identify the definition of the type. If the JSON Schema definition of the value type contains an "$anchor" member (see <<jsonschema_schemaconversionrules_types_classname_anchor>>), then the type name SHALL be used as fragment identifier. Otherwise, a JSON Pointer SHALL be created.

Examples:

* using the "$anchor" value "TypeX": https://example.org/schemaA/schema_definitions.json#TypeX
* using JSON Pointer:
** For a draft 07 JSON Schema: https://example.org/schemaA/schema_definitions.json#/definitions/TypeX
** For a 2019-09 JSON Schema: https://example.org/schemaA/schema_definitions.json#/$defs/TypeX

////

#TBD# This is so very specific that I doubt it makes sense to put this in the Best Practice specification. It could be moved to an Annex, but even that would be more confusing than helpful to the interested reader.

[[jsonschema_schemaconversionrules_properties_valuetype_valuetypeoptions]]
A specific rule has been added to support value type restrictions for UML properties, which in the NAS are defined using OCL constraints (for further details - and especially an example, see section <<jsonschema_schemaconversionrules_constraint>>): __rule-json-cls-valueTypeOptions__. This rule looks for tagged value __valueTypeOptions__ on a class. If the tag exists and has a value, it defines which types are allowed as value type for a given UML property. Note that this UML property can be directly defined on the class but also be inherited from a supertype. The property can also originally have been an association role that belonged to an association class. The conversion rule ensures that instead of the actual value type of the property, only one of the allowed types is encoded as type definition in the JSON Schema. The conversion also takes into account that the property may have been a role of an association class. The restriction to a set of allowed types uses an if-then-else construct, which depends on the presence of a type identifying member (see section <<jsonschema_schemaconversionrules_types_classname_typeidentification>>) in property values, and thus __rule-json-cls-valueTypeOptions__ should always be used in combination with __rule-json-cls-name-as-entityType__. Note that value type restrictions (defined on a subtype) of inherited UML properties will result in these properties being explicitly defined in the JSON Schema definition of the subtype. The JSON Schema types of the allowed (UML) types are determined as described before. Further details on how the tagged value __valueTypeOptions__ is structured and how it can be derived from OCL constraints are given in section <<jsonschema_transformationrules_valuetyperestrictionocl>>.

////

[[jsonschema_schemaconversionrules_properties_inlineOrByReference]]
The behavior described so far covers the case of an inline encoding of the property value. In some cases, particularly if the value type is a type with identity, it can be preferable and maybe even necessary to encode the value by reference. In other cases, both options should be offered. That is similar to what the GML Application Schema encoding rules support (for further details, see OGC 07-036r1, Annex E, section E.2.4.11).

[NOTE]
======
An example where a reference to an object is needed is when the object is the value of properties from multiple other objects that are encoded within the same JSON document. For example, a feature referenced from several other features. In such a situation, it is often desirable not to encode the object inline multiple times - especially if that object also referenced other objects.
======

UML properties within an application schema typically have a tagged value _inlineOrByReference_, with one of three values: _inlineOrByReference_, _byReference_, or _inline_.

[NOTE]
======
For the purpose of JSON Schema encoding, the default value for an empty or missing _inlineOrByReference_ tagged value is _byReference_ . That default value is different to GML. _byReference_ has been chosen as default in order to reduce the degrees of freedom and to reduce the schema complexity.

======

#TBD# Do we need multiple options for the byReference-encoding? Right now, we have both a URI option as well as the option of using a link object. Interestingly, there is an early activity of standardizing or harmonizing references in JSON: https://github.com/json-schema-org/referencing. However, that activity is still ongoing and right now there are competing proposals.

When encoding the value type of a UML property in JSON Schema, and that type is a type with identity which is not implemented as a simple JSON Schema type, the _inlineOrByReference_ tagged value SHALL be taken into account:

* If the tag value is _inline_, then the behavior described above is applied;
* Otherwise, if the tag value is _byReference_, then by default the "type" key of the property will be defined with value "string" and `"format": "uri"`. +
+
NOTE: The default behavior can be overridden by setting the ShapeChange JSON Schema target parameter _byReferenceJsonSchemaDefinition_. The parameter value is a URI to a JSON Schema definition of a link object, for example as shown in <<example_jsonschema_link_object>>. In actual JSON data, such a link object would be used to encode the reference.
* Otherwise, i.e., the tag value is _inlineOrByReference_, the two options above are combined using the "oneOf" keyword. +
+
NOTE: The result is an XOR type of check, i.e., a value can either be given inline or by reference, but not both. This is different to GML, where in the case of _inlineOrByReference_ and a complex value type a value can be given both inline and by reference.

NOTE: Some applications may prefer to reference types with identity using a code (of type string or number) instead of using a URI. That code could be seen as a foreign key. In such cases, a model transformation should be applied first, which, for all properties whose value type is a type with identity, replaces the value type with _CharacterString_ or __Number__.

NOTE: The conversion behavior for value types does not enable by reference encoding for value types that are data types. In general, a data type does not have identity, and therefore a data type value should always be encoded inline, not by reference. The XML Schema encoding rule defined by ISO 19139:2007, typically used to encode metadata schemas (as defined by ISO 19115, and extensions thereof), on the other hand, allows by reference encoding for data type values. When comparing the previous version of ISO 19115 (from 2003/2006) against the current version (from 2014), it is apparent that some classes that were defined as data types in the previous version are now defined as object types, for example _CI_Citation_. This indicates that the assignment of the \<<dataType>> stereotype has been corrected, in order to reflect in the conceptual model that the type shall be a type with identity.


[[jsonschema_schemaconversionrules_properties_multiplicity]]
===== Multiplicity

If the minimum cardinality of a UML property is 1 or greater, and the class that owns the property is not a \<<union>>, then the property SHALL be listed under the "required" properties of the JSON object to which the property belongs.

In addition, if the maximum cardinality of the property is greater than 1, then a JSON Schema SHALL be created for the property as follows.

* The "type" of the JSON property is set to "array", with the "items" keyword containing the JSON Schema constraints that are created to represent the value type of the property.
* If the minimum cardinality is greater than 0, it is encoded using the "minItems" keyword.
* If the maximum cardinality is not unbounded, it is encoded using the "maxItems" keyword.
* If the values of the property must be unique (which is the default for UML properties), then that is represented by adding `"uniqueItems": true`.

[#img_jsonschema_properties_multiplicity_example,reftext='{figure-caption} {counter:figure-num}']
.UML type used to exemplify JSON Schema encoding of multiplicity
image::images/Multiplicity_example.png[align="center"]

[#example_jsonschema_properties_multiplicity,reftext='{listing-caption} {counter:listing-num}']
.Example for encoding multiplicity in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type": {
      "type": "object",
      "properties": {
        "property": {
          "type": "array",
          "minItems": 1,
          "maxItems": 2,
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "required": [
        "property"
      ]
    }
  },
  "$ref": "#/definitions/Type"
}
----

This JSON object is valid against the schema from <<example_jsonschema_properties_multiplicity>>:

[source,json,linenumbers]
----
{
"property": ["a","b"]
}
----

This JSON object is invalid (because "property" has three values, which exceeds the maximum amount of allowed values) against the schema from <<example_jsonschema_properties_multiplicity>>:

[source,json,linenumbers]
----
{
"property": ["a","b",""]
}
----

NOTE: All arrays in JSON are ordered, thus that the values of a UML property are ordered is always represented, and that the values of such a property are unordered cannot be represented. However, the latter should not matter to an application that does not expect ordered values for a certain property.


[[jsonschema_schemaconversionrules_properties_voidable]]
===== Voidable

#TBD# Should we support stereotype \<<voidable>>, even if it is not defined by ISO 19103 or 19109? ... That is actually the same for TV _nillable_. That tag does not appear to be mentioned in ISO 19136. Should we just talk about "nillable" properties here, then, and state that communities may define their own rules on how to declare such properties in UML, giving \<<voidable>> and TV nillable as examples? -> Required by Geonovum? If not, we could just omit voidable.

The JSON Schema of a UML property with stereotype \<<voidable>>, or with tagged value _nillable_ = true, SHALL be defined in a way that only allows either a null value or a(n array of) actual value(s).

* If the UML property has maximum multiplicity 1, then a simple "type" restriction with value "null" is added to the type definition that is produced for the property.
* Otherwise - the maximum multiplicity is greater than 1 - a choice (encoded using the "oneOf" keyword) between a "null" value and an array of actual values will be created.

[#img_jsonschema_properties_voidable_example,reftext='{figure-caption} {counter:figure-num}']
.Example for JSON Schema encoding of a voidable property with max multiplicity 1
image::images/Voidable_example.png[align="center"]

[#example_jsonschema_properties_voidable_maxmult1,reftext='{listing-caption} {counter:listing-num}']
.Encoding a voidable UML property with max multiplicity 1 in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type1": {
      "type": "object",
      "properties": {
        "propertyA": {
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/Type2"
            }
          ]
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "Type2": {
      "type": "object",
      "properties": {
        "propertyB": {
          "type": "string"
        }
      },
      "required": [
        "propertyB"
      ]
    }
  },
  "$ref": "#/definitions/Type1"
}
----

The following two JSON objects are valid against the schema from <<example_jsonschema_properties_voidable_maxmult1>>:

[source,json,linenumbers]
----
{
  "propertyA": null
}
----

[source,json,linenumbers]
----
{
  "propertyA": {
    "propertyB": "x"
  }
}
----

This JSON object is invalid (because "propertyB" is not allowed to be null) against the schema from <<example_jsonschema_properties_voidable_maxmult1>>:

[source,json,linenumbers]
----
{
  "propertyA": {
    "propertyB": null
  }
}
----

If propertyA from the example shown in <<img_jsonschema_properties_voidable_example>> had maximum multiplicity of "*", then the resulting JSON Schema would be as in <<example_jsonschema_properties_voidable_maxmultgreater1>>

[#example_jsonschema_properties_voidable_maxmultgreater1,reftext='{listing-caption} {counter:listing-num}']
.Encoding a voidable UML property with max multiplicity greater than 1 in JSON Schema
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Type1": {
      "type": "object",
      "properties": {
        "propertyA": {
          "oneOf": [
            {
              "type": "null"
            },
            {
              "type": "array",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/Type2"
              },
              "uniqueItems": true
            }
          ]
        }
      },
      "required": [
        "propertyA"
      ]
    },
    "Type2": {
      "type": "object",
      "properties": {
        "propertyB": {
          "type": "string"
        }
      },
      "required": [
        "propertyB"
      ]
    }
  },
  "$ref": "#/definitions/Type1"
}
----

NOTE: To encode the nil/null reason, a separate, parallel property "xyz_nilReason" (or similar) could be added, using a model transformation.


[[jsonschema_schemaconversionrules_properties_readonly]]
===== Fixed / readOnly

The JSON Schema definition of a UML property that is read only or fixed SHALL include the "readOnly" annotation with JSON value true.

#TBD# Shall we encode derived properties? If so, the NOTE should become a separate section.

NOTE: A UML property marked as derived SHALL also be encoded with `"readOnly": true`.


[[jsonschema_schemaconversionrules_properties_initialvalue]]
===== Initial Value

The JSON Schema definition of a UML attribute that has an initial value, is not owned by an enumeration or code list, and whose value type is encoded as one of the simple JSON Schema types "string", "number", "integer", or "boolean", SHALL include the "default" annotation with the initial value as value.

The value of the annotation can have any JSON value type. The initial value SHALL be encoded accordingly: 

* quoted, if the property type is "string";
* unquoted if the property type is "number" or "integer"; and 
* true if the property type is "boolean" and the initial value is equal to, ignoring case, "true"; otherwise the value is false. 

NOTE: Theoretically, the default value can also be a JSON array or object, but that cannot be represented in UML and thus is not a relevant use case.

[[jsonschema_schemaconversionrules_associationclass]]
==== Association Class

There is no native represention for association classes in JSON or JSON Schema. For schemas that include association classes, a transformation of association classes as defined by GML 3.3 should be used.


[[jsonschema_schemaconversionrules_constraint]]
==== Constraints

OCL constraints can be used to enrich a conceptual model with requirements that cannot be expressed in UML alone. However, this specification does not define any requirements for converting OCL constraints to JSON Schema definitions, or to any other format with which the constraints can be checked on a JSON dataset.


[[jsonschema_instanceconversionrules]]
=== Instance Conversion Rules

#TBD# Should we move this section (or rather: its only subsection) to an informative Annex? ... it could simplify the document structure (potentially reducing the level of section nesting by one) -> separation in schema and instance conversion rules may be artificial ... assignment of the GeoJSON "id" feature member would be another requirement for the instance creation. So in fact, we can simplify the document structure, but still have requirements for JSON instances (i.e., the encoding of actual data).

This section documents recommendations and relevant aspects for encoding geospatial data in JSON.

[[jsonschema_instanceconversionrules_geojson_crs]]
==== Coordinate Reference System in JSON data

The <<ref_geojson,GeoJSON standard>> requires that all GeoJSON coordinates use __urn:ogc:def:crs:OGC::CRS84__ as coordinate reference system (CRS), with optional height in meters above or below the WGS 84 reference ellipsoid. Alternative CRSs are not allowed by this standard.

The <<ref_ogcapi_features_part1,OGC API - Features - Part 1: Core>> standard essentially has the same requirement:

[quote,OGC API - Features - Part 1: Core; section 7.11]
____
Unless the client explicitly requests a different coordinate reference system, all spatial geometries SHALL be in the coordinate reference system http://www.opengis.net/def/crs/OGC/1.3/CRS84 (WGS 84 longitude/latitude) for geometries without height information and http://www.opengis.net/def/crs/OGC/0/CRS84h (WGS 84 longitude/latitude plus ellipsoidal height) for geometries with height information.
____

A previous version of the GeoJSON standard did allow alternative CRSs, but that option has been removed _"because the use of different coordinate reference systems has proven to have interoperability issues"_ (<<ref_geojson,GeoJSON standard>>, chapter 4). However, the GeoJSON standard also states that if all involved parties have a prior arrangement, then alternative CRSs can be used.

The <<ref_ogcapi_features_part1,OGC API - Features - Part 1: Core>> standard also does not preclude the use of additional CRSs, but does not specify how to request features in such reference systems. That is the purpose of _OGC API - Features - Part 2: Coordinate Reference Systems by Reference_, which is currently under development.

To summarize: Coordinates of GeoJSON compliant data as well as spatial data accessed using the _OGC API - Features_ standard must be given in OGC CRS84 (with optional height). That has implications for data publishers and consumers. A major benefit is increased interoperability, because spatial datasets that use the same CRS can easily be merged. If a use case requires other CRSs, then both GeoJSON and the OGC API - Features standards have options to support that. Data publisher and consumer only need to agree on the CRS in which the coordinates of spatial data, that is being exchanged between the two, is given in.


[[jsonschema_transformationrules]]
=== Conceptual Model Transformation Rules

#TBD# Suggest to completely remove this section! Too ShapeChange-specific and too complex. We can leave all model transformations desired by communities up to them, I think. -> ii recommendation: rather just state that certain model transformations may be necessary (giving some examples), and thus creating an implementation schema, before applying the JSON Schema encoding rules. Also document which UML constructs that are supported in application schema modeling (by ISO 19103, 19109, and 19136) are not supported (e.g. association classes).

The conceptual schema may need to be transformed, in order to deal with model elements:

* that cannot be represented in JSON at all (e.g., association classes);
* that cannot be represented in a certain JSON format (e.g., a Solid - a 3D geometry type - as value for the "geometry" member of a GeoJSON feature); or
* that are not (well) supported by client software (e.g., complex attribute values for styling, processing, and filtering).

The following sections describe model transformations that can be useful to deal with these restrictions when encoding application schemas as JSON Schemas.

[[jsonschema_transformationrules_inheritance]]
==== Flattening Inheritance

As mentioned in section <<jsonschema_schemaconversionrules_types_inheritance>>, JSON Schema does not directly support the concept of inheritance. There are ways to represent inheritance in JSON Schema to a certain extent. Generalization can be represented using an "allOf" that includes the schema of a subtype and the schema(s) of its supertype(s). Specialization can be represented as a relatively complex if-then-else construct, with which JSON objects - that encode types from a type hierarchy) can be validated based upon a property value that declares their type.

If a community does not want to apply these solutions for representing inheritance in JSON Schema, but still wants to use inheritance in their concpetual model and derive a JSON Schema encoding from it, then inheritance needs to be transformed on the conceptual level. Generalization (in the sense of <<jsonschema_schemaconversionrules_types_inheritance_generalization>>) would be transformed by copying all properties of a supertype down to direct and indirect subtypes. For each supertype, a union of the non-abstract types in the hierarchy of that supertype (including the supertype itself) would be created, and the value type of each property that is that supertype would be switched to the union. That would allow the encoding of subtypes, instead of the supertype, as property value - and thus support specialization (in the sense of <<jsonschema_schemaconversionrules_types_inheritance_specialization>>).

The transformation of inheritance is implemented by the ShapeChange __Flattener__ transformer, in __rule-trf-cls-flatten-inheritance__. The https://shapechange.net/transformations/flattener/#rule-trf-cls-flatten-inheritance[documentation of the rule] provides further details.

NOTE: The introduction of new unions as value types, for properties that have a supertype as value type, creates a level of indirection that may not be desirable. One approach to avoid the indirection would be to flatten the unions using another transformation, i.e., <<jsonschema_transformationrules_complextypes>> (though that would create additional properties and remove the union semantics). Another approach would be to encode these unions as object references. This approach has been used in the creation of a GML-SF Level 0 XML Schema in OGC Testbed 13 (for further details, see the http://docs.opengeospatial.org/per/17-020r1.html#GMLSF0_XSD[OGC Testbed-13: NAS Profiling Engineering Report, section 7.2.19. XML Schema encoding, rule-xsd-cls-union-omitUnionsRepresentingFeatureTypeSets].

[[jsonschema_transformationrules_multiplicity]]
==== Flattening Multiplicity

Simple JSON formats may not support properties with a maximum multiplicity greater than 1. If the conceptual model contains such properties, they can be transformed to a set of properties, each with maximum multiplicity = 1.

This kind of model transformation is implemented in ShapeChange by https://shapechange.net/transformations/flattener/#rule-trf-prop-flatten-multiplicity[rule-trf-prop-flatten-multiplicity] of the __Flattener__ transformer.



[[jsonschema_transformationrules_complextypes]]
==== Flattening Complex Types

A community may want to keep their JSON formats simple by not allowing nested objects within a JSON object, or only a bare minimum (e.g., when their JSON shall be GeoJSON compliant). In such a case, nested objects that represent data types and unions from the conceptual model must be avoided. At the same time, the JSON formats used by the community must still be able to represent the information items that would usually be encoded via these complex types.

https://shapechange.net/transformations/flattener/#rule-trf-prop-flatten-types[rule-trf-prop-flatten-types], implemented by the ShapeChange __Flattener__ transformer, "flattens" these complex types by copying their properties to the types that use the complex types. The names of the property copies are modified to reflect which information items they represent.

[[jsonschema_transformationrules_associationclasses]]
==== Mapping Association Classes

JSON Schema cannot directly represent association classes. An association class therefore needs to be transformed into a structure that can be represented with JSON Schema. The transformation of association classes defined by GML 3.3 is a suitable solution.

The ShapeChange https://shapechange.net/transformations/association-class-mapper/[Association Class Mapper] implements the transformation defined by GML 3.3.

[[jsonschema_transformationrules_propertymetadata]]
==== Transforming Stereotype \<<propertyMetadata>>

In the UGAS-2019 OGC Pilot, the \<<propertyMetadata>> stereotype was developed. When assigned to a property, it indicates that the property can be associated with metadata. The metadata would provide additional information on the property value or values. Tagged value __metadataType__ is defined for the stereotype, and used to identify the actual type that the property references as metadata.

The https://shapechange.net/wp-content/uploads/2019/12/UGAS19-D100_property_stereotypes.pdf[Property Stereotype for Metadata] document describes how the stereotype is encoded in XML Schema. Basically, a "metadata" XML attribute is added on the XML element that represent the property. The XML attribute can be used to reference the metadata object, much like an "xlink:href" XML attribute would be used to reference a "normal" object.

Some encodings - like JSON - do not have anything similar to XML attributes. Section 2.3.2 of the https://shapechange.net/wp-content/uploads/2019/12/UGAS19-D100_property_stereotypes.pdf[Property Stereotype for Metadata] document describes how the \<<propertyMetadata>> stereotype can be handled in such an encoding. In essence, the stereotype is transformed to an additional property, with the type identified by tagged value __metadataType__ as value type.

The transformation is implemented by the ShapeChange __Type Converter__ transformer in __rule-trf-propertyMetadata-stereotype-to-metadata-property__.

* Rule behavior: Converts the \<<propertyMetadata>> stereotype to an additional property, as follows: First, the metadata type that applies to the property with the stereotype is identified: The tagged value __metadataType__ of the property is checked first. If the tagged value does not identify a metadata type, then the type defined by configuration parameter __defaultMetadataType__ is used.
+
[NOTE]
======
The identification of the metadata type by tagged value or by configuration parameter is as follows:

* definition by tagged value _metadataType_: If the type is defined by the schema that contains the property, then the tagged value simply provides the name of the type. Otherwise, the tagged value shall identify the type by its full package-qualified name, starting with the application schema package. For example: "Some Application Schema::Some Subpackage::Another Subpackage::MetadataType."
* definition by configuration parameter _defaultMetadataType_: If the name of the type is unique within the conceptual model, then simply providing the type name as parameter value is sufficient. Otherwise (or as a general alternative), the metadata type is identified by providing its full name (omitting packages that are outside of the schema the class belongs to - see the example above).
======
+
If the configuration parameter also does not identify a type within the conceptual model, an error message will be logged and the stereotype will simply be removed from the property. Otherwise, if the metadata type is a type with identity (feature or object type) then a directed association to the metadata type is created - else an attribute (with the metadatatype as value type) is created. The name of the new association role or attribute is the property name plus suffix defined by configuration parameter __metadataPropertyNameSuffix__. If a new association role was created, tagged value __inlineOrByReference__ of the association role is set to the value defined by configuration parameter __metadataPropertyInlineOrByReference__. Otherwise, i.e., an attribute was created, tagged value __inlineOrByReference__ is set to "inline." Tagged value _sequenceNumber_ will be set in such a way that the new property is placed directly after the original property.
* Configuration parameter __defaultMetadataType__: Name of the type from the conceptual model, which shall be used as metadata type for all properties with stereotype \<<propertyMetadata>> that do not define a metadata type via tagged value __metadataType__. The value can be the pure type name, if it is unique within the conceptual model. Otherwise, the correct type is identified by providing its full name (omitting packages that are outside of the schema the class belongs to). The default value for this parameter is 'MD_Metadata' (which typically refers to the type defined by ISO 19115).
* Configuration parameter __metadataPropertyNameSuffix__: Defines the suffix that shall be added to the name of a new property created by __rule-trf-propertyMetadata-stereotype-to-metadata-property__. Default is'_metadata'.
* Configuration prameter __metadataPropertyInlineOrByReference__: Defines the value for tag __inlineOrByReference__ of a new association role created by __rule-trf-propertyMetadata-stereotype-to-metadata-property__. Default is 'inlineOrByReference'. Other allowed values are 'byReference' and 'inline'.



[[jsonschema_transformationrules_nilreason_property]]
==== Generating NilReason Properties for Nillable Properties

// implementation status: implemented

A UML property that is defined for a feature, object, data, or union type within an application schema, by default cannot have a null value. In order to model that a property can have a null value (instead of actual value(s)), stereotype \<<voidable>> must be added to the property, or tagged value _nillable_ with value 'true'. Such a property is called a _nillable_ property.

The recommendation from the UGAS-2019 OGC Pilot for NAS modelling of nillable properties (for further details, see the https://shapechange.net/wp-content/uploads/2019/12/UGAS19-D100_property_stereotypes.pdf[Property Stereotype for Metadata] document, section 2.2) is to use the \<<voidable>> stereotype, and to also set tagged value _voidReasonType_ on the property, in order to define the enumeration that defines the reasons for a null value.

In the XML Schema encoding, nillable properties are represented by XML elements for which the XML attribute "nilReason" can be set. As also mentioned in section <<jsonschema_transformationrules_propertymetadata>>, some encodings - like JSON - do not have anything similar to XML attributes. In order to encode the reason why a nillable property has a null value in such an encoding, the application schema can be transformed, adding a new property for each nillable property (to the class that owns the nillable property), with the new property having the void reason type as value type.

The according transformation is implemented by the ShapeChange __Type Converter__ transformer in __rule-trf-nilReason-property-for-nillable-property__.

* Rule behavior: For each property that is nillable (has stereotype \<<voidable>> or tagged value _nillable_ set to 'true'), create a new attribute, as follows: First, the void reason type that applies to the nillable property is identified: The tagged value _voidReasonType_ of the nillable property is checked first. If the tagged value does not exist or does not identify a type, then the type defined by configuration parameter _defaultVoidReasonType_ is used.
+
[NOTE]
======
The identification of the void reason type by tagged value or by configuration parameter is as follows.

* Definition by tagged value _voidReasonType_: If the type is defined by the schema that contains the property, then the tagged value simply provides the name of the type. Otherwise, the tagged value shall identify the type by its full package-qualified name, starting with the application schema package. For example: "Some Application Schema::Some Subpackage::Another Subpackage::VoidReasonType".
* Definition by configuration parameter _defaultVoidReasonType_: If the name of the type is unique within the conceptual model, then simply providing the type name as parameter value is sufficient. Otherwise (or as a general alternative), the void reason type is identified by providing its full name (omitting packages that are outside of the schema the class belongs to - see the example above).
======
+
If the configuration parameter also is not set or does not identify a type within the conceptual model, an error message will be logged and the value type of the new attribute will be CharacterString. Otherwise, the identified type will be set as value type of the new attribute. The name of the new attribute is the name of the nillable property plus suffix defined by configuration parameter _nilReasonPropertyNameSuffix_. Tagged value _inlineOrByReference_ of the new attribute is set to inline. Tagged value _sequenceNumber_ will be set in such a way that it is placed directly after the nillable property.
* Configuration parameter __defaultVoidReasonType__: Name of the type from the conceptual model, which shall be used as void reason type for all nillable properties that do not define a void reason type via tagged value _voidReasonType_. The value can be the pure type name, if it is unique within the conceptual model. Otherwise, identify the correct type by providing its full name (omitting packages that are outside of the schema the class belongs to). No default value is defined for this parameter.
* Configuration parameter __nilReasonPropertyNameSuffix__: Defines the suffix that shall be added to the name of a new property created by __rule-trf-nilReason-property-for-nillable-property__. Default is'_nilReason'.

[[jsonschema_transformationrules_valuetyperestrictionocl]]
==== Transforming OCL Constraints Defining Value Type Restrictions

// implementation status: implemented

An OCL constraint such as `inv: place->forAll(p|not(p.oclIsKindOf(CurvePositionSpecification) or p.oclIsKindOf(SurfacePositionSpecification)))`, and - for the sake of the example used in this section - name "Value Type Representations Disallowed", restricts the set of allowed value types for a property. In the example, property _place_ must not have a value of type _CurvePositionSpecification_ or _SurfacePositionSpecification_. The example is described in more detail in section <<jsonschema_schemaconversionrules_constraint>>.

With __rule-trf-cls-constraints-valueTypeRestrictionToTV-exclusion__ - defined for the https://shapechange.net/transformations/constraintconverter/[ShapeChange _ConstraintConverter_ transformation], the value type restrictions defined by OCL constraints can be extracted from the OCL expression, and converted into a tagged value, to be used by subsequent transformation and conversion processes.

Configuration parameter __valueTypeRepresentationConstraintRegex__ is used to identify the relevant OCL constraints. The parameter value contains a regular expression - for example `.\*Value Type Representations Disallowed.*`, which matches the names of OCL constraints that define value type restrictions. The according OCL expressions must thereby be structured as in the example (with _oclIsTypeOf(..)_ also being supported).

The name of the property that is restricted is parsed from the begin of the OCL expression: `inv: _{propertyName}_\->forAll`... The property name may thereby be preceded by `self.`, i.e., `inv: self._{propertyName}_\->forAll`... is a valid alternative way to structure the value type restricting OCL expression.

Required configuration parameter __valueTypeRepresentationTypes__ specifies the types that are used as value type by the UML properties identified in the value type restricting OCL constraints. For each such type, a list of names of the generally allowed types within the inheritance hierarchy of that type must be provided, which may include the type itself and abstract types. For example, for the value type _PlaceSpecification_ of property _place_ shown in REF img_jsonschema_value_type_options_example, the value of the configuration parameter could be: `PlaceSpecification{PointPositionSpecification, CurvePositionSpecification, SurfacePositionSpecification, LocationSpecification}`. The transformation will automatically add all subtypes of generally allowed types to the set of generally allowed types. That is important for creating a tagged value that explicitly lists the types that are allowed for a property, regardless of inheritance structures, because the OCL constraint may exclude a specific subtype of a generally allowed supertype.

NOTE: If multiple value types need to be described by configuration parameter __valueTypeRepresentationTypes__, then a semicolon is used to separate the descriptions in the parameter value.

The transformation will parse a value type restricting OCL constraint in order to determine the (potentially inherited) UML property to which the constraint applies. The OCL expression is structured so that any type mentioned in the expression is disallowed/excluded. The transformation can therefore determine the value types that are disallowed - also taking into account all subtypes of a type that is mentioned within an _oclIsKindOf(..)_. The set of disallowed types will then be subtracted from the set of generally allowed types, resulting in the set of types that are allowed as value types of the property.

The allowed types for the property are documented in the model by adding (also: overwriting, if it already exists) tagged value _valueTypeOptions_ to the class on which the UML property is defined. The tagged value is structured as follows:

`{propertyName}(\(associationClassRole\))?={allowedTypeName}(,{allowedTypeName})*(;{propertyName}(\(associationClassRole\))?={allowedTypeName}(,{allowedTypeName})*)*`

For the example OCL constraint, that would result in: `place(associationClassRole)=PointPositionSpecification,LocationSpecification`.

NOTE: The example shows that the tagged value may contain a qualifier - _associationClassRole_ - for a property, which, if set, indicates that the property is an association role whose association actually is an association class. That information can be relevant for subsequent processes, for example the JSON Schema encoding, when a previous model transformation has transformed association classes as defined by the GML 3.3 encoding rules.

NOTE: Configuration parameter __valueTypeRepresentationTypes__ can also define an alias for the name of an allowed type. For example: `PlaceSpecification{PointPositionSpecification=P, CurvePositionSpecification=C, SurfacePositionSpecification=S, LocationSpecification=L}`. The alias is used when constructing tagged value _valueTypeOptions_. That can be useful in case that the names of UML types contained in the model are flattened, i.e., replaced by a short name or code, by a subsequent model transformation. Processes that convert such a flattened model and use the information from tagged value _valueTypeOptions_ then have the correct names of allowed value types.

[[jsonschema_encodingrules]]
=== Encoding Rules

#NOTE# JE has not modified these sections, yet. The intent is to solve all TBDs first.

This section documents two JSON Schema encoding rules, one for achieving a GeoJSON compliant JSON Schema encoding, and one for producing plain JSON Schemas (typically for non-geospatial schemas).

NOTE: Each of these two rules is implemented in ShapeChange, the first with name "defaultGeoJson", and the second with name "defaultPlainJson". Additional conversion rules can easily be added to such an encoding rule by defining a new encoding rule in the ShapeChange JSON Schema target that extends "defaultGeoJson" or "defaultPlainJson", and setting the new rule as the default encoding rule (using the ShapeChange JSON Schema target parameter _defaultEncodingRule_). If, on the other hand, conversion rules from "defaultGeoJson" or "defaultPlainJson" need to be removed or replaced, for any reason, then these encoding rules cannot be used (ShapeChange supports extending a named encoding rule, but not restricting it), and instead a new encoding rule must be defined that is patterned after the applicable existing rule.

[[applying_specific_encoding_rule_to_model_element]]
NOTE: For some application schemas, it is useful to know that different encoding rules can be applied to the subpackages, classes, and properties defined by the schema. Typically, a single encoding rule applies to all application schema elements. In ShapeChange, that rule is identified by setting the JSON Schema target parameter _defaultEncodingRule_, with the unique name defined for the encoding rule in the target configuration. The target configuration, however, can contain multiple encoding rules (with different names). By setting tagged value _jsonEncodingRule_ on an application schema element, using the name of another encoding rule, the model element will be encoded as defined by that rule. For example, if an application schema used unions in both ways described in section <<jsonschema_schemaconversionrules_types_union>>, then the default encoding rule could include __rule-json-cls-union-propertyCount__, and encoding rule "TypeDiscriminatorUnionRule" could instead include __rule-json-cls-union-typeDiscriminator__. By setting tagged value _jsonEncodingRule=TypeDiscriminatorUnionRule_ on each type discriminator union, these unions would be encoded using __rule-json-cls-union-typeDiscriminator__ and all other unions would be encoded using __rule-json-cls-union-propertyCount__.

[[jsonschema_encodingrules_geojson]]
==== GeoJSON Schema Encoding Rule

In order to achieve a GeoJSON compliant encoding using ShapeChange, set "defaultGeoJson" as the default encoding rule for the JSON Schema target (using the target parameter _defaultEncodingRule_).

This encoding rule consists of the following conversion rules:

* rule-json-cls-defaultGeometry-singleGeometryProperty
* rule-json-cls-ignoreIdentifier
* rule-json-cls-name-as-anchor
* rule-json-cls-nestedProperties
* rule-json-cls-virtualGeneralization
* rule-json-prop-derivedAsReadOnly
* rule-json-prop-initialValueAsDefault
* rule-json-prop-readOnly
* rule-json-prop-voidable

Furthermore, the following parameters need to be added to the configuration of the ShapeChange JSON Schema target:

* baseJsonSchemaDefinitionForFeatureTypes = https://geojson.org/schema/Feature.json
* baseJsonSchemaDefinitionForObjectTypes = https://geojson.org/schema/Feature.json

Geometry types used in the conceptual model (e.g., types from ISO 19107) must be mapped to one of the GeoJSON geometry types (see <<table_jsonschema_encodingrules_geojson_geometrymappings>>).

[#table_jsonschema_encodingrules_geojson_geometrymappings,reftext='{table-caption} {counter:table-num}']
.Mapping ISO 19107 types to GeoJSON geometry types
[cols="1,3a",options="header"]
|====================
| Conceptual geometry type | GeoJSON geometry type
| GM_Point | https://geojson.org/schema/Point.json
| GM_Curve | https://geojson.org/schema/LineString.json
| GM_Surface | https://geojson.org/schema/Polygon.json
| GM_MultiPoint | https://geojson.org/schema/MultiPoint.json
| GM_MultiCurve | https://geojson.org/schema/MultiLineString.json
| GM_MultiSurface | https://geojson.org/schema/MultiPolygon.json
| GM_Object | https://geojson.org/schema/Geometry.json
|====================

NOTE: In order to achieve an OGC JSON encoding, the ShapeChange JSON Schema target parameters _baseJsonSchemaDefinitionForFeatureTypes_ and _baseJsonSchemaDefinitionForObjectTypes_ would have to be set to reference the schema for AnyFeature, shown in #TBD# REF jsonschema_feature. Furthermore, the geometry types would need to be mapped as defined in REF table_profiles_core_spatialtypes_jsimpl.

The feature type illustrated in <<img_jsonschema_encrule_geojson_uml>> is used as example for a GeoJSON based encoding, which is shown in <<example_jsonschema_encrule_geojson>>.

[#img_jsonschema_encrule_geojson_uml,reftext='{figure-caption} {counter:figure-num}']
.Example of a feature type in UML, which will be converted to a GeoJSON feature
image::images/GeoJSON_example.png[align="center"]

[#example_jsonschema_encrule_geojson,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a feature type that is converted using the default GeoJSON encoding rule
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeG": {
      "$id": "#TypeG",
      "allOf": [
        {
          "$ref": "https://geojson.org/schema/Feature.json"
        },
        {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "properties": {
                "propertyG": {
                  "type": "number"
                }
              },
              "required": [
                "propertyG"
              ]
            },
            "geometry": {
              "$ref": "http://geojson.org/schema/Point.json"
            }
          },
          "required": [
            "properties"
          ]
        }
      ]
    }
  },
  "$ref": "#/definitions/TypeG"
}
----

This JSON object is valid against the schema from <<example_jsonschema_encrule_geojson>>:

[source,json,linenumbers]
----
{
  "id": "42445fdasd7asd6f7",
  "type": "Feature",
  "geometry": {
    "type": "Point",
    "coordinates": [8.195669, 51.903589]
  },
  "properties": {
    "propertyG": 3
  }
}
----

This JSON object is invalid against the schema from <<example_jsonschema_encrule_geojson>> (because the JSON value of "geometry" is not valid according to the JSON Schema of a GeoJSON point):

[source,json,linenumbers]
----
{
  "id": "42445fdasd7asd6f7",
  "type": "Feature",
  "geometry": {
    "type": "LineString",
    "coordinates": [
      [102.0,0.0],
      [103.0,1.0],
      [104.0,0.0],
      [105.0,1.0]
    ]
  },
  "properties": {
    "propertyG": 3
  }
}
----

[[jsonschema_encodingrules_plainjson]]
==== Plain JSON Schema Encoding Rule

Some communities have schemas where "geospatial" plays a minor or no role at all. For such cases, the use of GeoJSON features is not relevant. The property nesting and the restrictions of the "type" and "geometry" members defined by the GeoJSON schema could even be a hindrance.

In order to achieve a plain JSON Schema encoding using ShapeChange, set "defaultPlainJson" as the default encoding rule for the JSON Schema target (using the target parameter _defaultEncodingRule_).

This encoding rule consists of the following conversion rules:

* rule-json-cls-name-as-anchor
* rule-json-prop-derivedAsReadOnly
* rule-json-prop-initialValueAsDefault
* rule-json-prop-readOnly
* rule-json-prop-voidable

The geometry types used in the conceptual model should be mapped to the JSON Schema implementations defined by the REF table_profiles_core_spatialtypes_jsimpl,Features Core Profile.

A plain JSON Schema encoding of the feature type that was used as example for the GeoJSON based encoding in the previous section (see <<img_jsonschema_encrule_geojson_uml>>) is shown in <<example_jsonschema_encrule_plainjson>>.

[#example_jsonschema_encrule_plainjson,reftext='{listing-caption} {counter:listing-num}']
.JSON Schema example of a feature type that is converted using the default plain encoding rule
[source,json,linenumbers]
----
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "TypeG": {
      "$id": "#TypeG",
      "type": "object",
      "properties": {
        "location": {
          "$ref": "http://geojson.org/schema/Point.json"
        },
        "propertyG": {
          "type": "number"
        }
      },
      "required": [
        "location",
        "propertyG"
      ]
    }
  },
  "$ref": "#/definitions/TypeG"
}
----

This JSON object is valid against the schema from <<example_jsonschema_encrule_plainjson>>:

[source,json,linenumbers]
----
{
  "location": {
    "type": "Point",
    "coordinates": [
      8.195669,
      51.903589
    ]
  },
  "propertyG": 3
}
----